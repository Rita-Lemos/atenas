{"ast":null,"code":"/*\n This file is auto-generated, do not edit\n*/\n'use strict';\n\nconst rqs = require(\"./request\");\n/**\n * Merges interactions (purchases, ratings, bookmarks, detail views ...) of two different users under a single user ID. This is especially useful for online e-commerce applications working with anonymous users identified by unique tokens such as the session ID. In such applications, it may often happen that a user owns a persistent account, yet accesses the system anonymously while, e.g., putting items into a shopping cart. At some point in time, such as when the user wishes to confirm the purchase, (s)he logs into the system using his/her username and password. The interactions made under anonymous session ID then become connected with the persistent account, and merging these two together becomes desirable.\n * Merging happens between two users referred to as the *target* and the *source*. After the merge, all the interactions of the source user are attributed to the target user, and the source user is **deleted**.\n */\n\n\nclass MergeUsers extends rqs.Request {\n  /**\n   * Construct the request\n   * @param {string} targetUserId - ID of the targer user.\n   * @param {string} sourceUserId - ID of the source user.\n   * @param {Object} optional - Optional parameters given as an object with structure name of the parameter: value\n   * - Allowed parameters:\n   *     - *cascadeCreate*\n   *         - Type: boolean\n   *         - Description: Sets whether the user *targetUserId* should be created if not present in the database.\n   */\n  constructor(targetUserId, sourceUserId, optional) {\n    super('PUT', `/users/${encodeURIComponent(targetUserId)}/merge/${encodeURIComponent(sourceUserId)}`, 30000, false);\n    this.targetUserId = targetUserId;\n    this.sourceUserId = sourceUserId;\n    optional = optional || {};\n    this.cascadeCreate = optional.cascadeCreate;\n  }\n  /**\n   * Get body parameters\n   * @return {Object} The values of body parameters (name of parameter: value of the parameter)\n   */\n\n\n  bodyParameters() {\n    let params = {};\n    params.cascadeCreate = this.cascadeCreate !== undefined ? this.cascadeCreate : true;\n    return params;\n  }\n\n}\n\nexports.MergeUsers = MergeUsers;","map":{"version":3,"sources":["C:/xampp/htdocs/laravel-base/node_modules/recombee-js-api-client/src/requests/merge-users.js"],"names":["rqs","require","MergeUsers","Request","constructor","targetUserId","sourceUserId","optional","encodeURIComponent","cascadeCreate","bodyParameters","params","undefined","exports"],"mappings":"AAAA;;;AAIA;;AACA,MAAMA,GAAG,GAAGC,OAAO,CAAC,WAAD,CAAnB;AAEA;;;;;;AAIA,MAAMC,UAAN,SAAyBF,GAAG,CAACG,OAA7B,CAAqC;AAEnC;;;;;;;;;;AAUAC,EAAAA,WAAW,CAACC,YAAD,EAAeC,YAAf,EAA6BC,QAA7B,EAAuC;AAChD,UAAM,KAAN,EAAc,UAASC,kBAAkB,CAACH,YAAD,CAAe,UAASG,kBAAkB,CAACF,YAAD,CAAe,EAAlG,EAAqG,KAArG,EAA4G,KAA5G;AACA,SAAKD,YAAL,GAAoBA,YAApB;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACAC,IAAAA,QAAQ,GAAGA,QAAQ,IAAI,EAAvB;AACA,SAAKE,aAAL,GAAqBF,QAAQ,CAACE,aAA9B;AACD;AAED;;;;;;AAIAC,EAAAA,cAAc,GAAG;AACf,QAAIC,MAAM,GAAG,EAAb;AAEAA,IAAAA,MAAM,CAACF,aAAP,GAAwB,KAAKA,aAAL,KAAuBG,SAAxB,GAAqC,KAAKH,aAA1C,GAA0D,IAAjF;AACA,WAAOE,MAAP;AACD;;AA7BkC;;AAiCrCE,OAAO,CAACX,UAAR,GAAqBA,UAArB","sourcesContent":["/*\n This file is auto-generated, do not edit\n*/\n\n'use strict';\nconst rqs = require(\"./request\");\n\n/**\n * Merges interactions (purchases, ratings, bookmarks, detail views ...) of two different users under a single user ID. This is especially useful for online e-commerce applications working with anonymous users identified by unique tokens such as the session ID. In such applications, it may often happen that a user owns a persistent account, yet accesses the system anonymously while, e.g., putting items into a shopping cart. At some point in time, such as when the user wishes to confirm the purchase, (s)he logs into the system using his/her username and password. The interactions made under anonymous session ID then become connected with the persistent account, and merging these two together becomes desirable.\n * Merging happens between two users referred to as the *target* and the *source*. After the merge, all the interactions of the source user are attributed to the target user, and the source user is **deleted**.\n */\nclass MergeUsers extends rqs.Request {\n\n  /**\n   * Construct the request\n   * @param {string} targetUserId - ID of the targer user.\n   * @param {string} sourceUserId - ID of the source user.\n   * @param {Object} optional - Optional parameters given as an object with structure name of the parameter: value\n   * - Allowed parameters:\n   *     - *cascadeCreate*\n   *         - Type: boolean\n   *         - Description: Sets whether the user *targetUserId* should be created if not present in the database.\n   */\n  constructor(targetUserId, sourceUserId, optional) {\n    super('PUT', `/users/${encodeURIComponent(targetUserId)}/merge/${encodeURIComponent(sourceUserId)}`, 30000, false);\n    this.targetUserId = targetUserId;\n    this.sourceUserId = sourceUserId;\n    optional = optional || {};\n    this.cascadeCreate = optional.cascadeCreate;\n  }\n\n  /**\n   * Get body parameters\n   * @return {Object} The values of body parameters (name of parameter: value of the parameter)\n   */\n  bodyParameters() {\n    let params = {};\n\n    params.cascadeCreate = (this.cascadeCreate !== undefined) ? this.cascadeCreate : true;\n    return params;\n  }\n\n}\n\nexports.MergeUsers = MergeUsers\n"]},"metadata":{},"sourceType":"script"}