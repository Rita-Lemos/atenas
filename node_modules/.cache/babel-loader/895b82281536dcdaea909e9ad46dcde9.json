{"ast":null,"code":"/** @license React v2.3.0\n * eslint-plugin-react-hooks.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n    /* eslint-disable no-for-of-loops/no-for-of-loops */\n\n    /**\n     * Catch all identifiers that begin with \"use\" followed by an uppercase Latin\n     * character to exclude identifiers like \"user\".\n     */\n\n    function isHookName(s) {\n      return /^use[A-Z0-9].*$/.test(s);\n    }\n    /**\n     * We consider hooks to be a hook name identifier or a member expression\n     * containing a hook name.\n     */\n\n\n    function isHook(node) {\n      if (node.type === 'Identifier') {\n        return isHookName(node.name);\n      } else if (node.type === 'MemberExpression' && !node.computed && isHook(node.property)) {\n        // Only consider React.useFoo() to be namespace hooks for now to avoid false positives.\n        // We can expand this check later.\n        var obj = node.object;\n        return obj.type === 'Identifier' && obj.name === 'React';\n      } else {\n        return false;\n      }\n    }\n    /**\n     * Checks if the node is a React component name. React component names must\n     * always start with a non-lowercase letter. So `MyComponent` or `_MyComponent`\n     * are valid component names for instance.\n     */\n\n\n    function isComponentName(node) {\n      if (node.type === 'Identifier') {\n        return !/^[a-z]/.test(node.name);\n      } else {\n        return false;\n      }\n    }\n\n    function isInsideComponentOrHook(node) {\n      while (node) {\n        var functionName = getFunctionName(node);\n\n        if (functionName) {\n          if (isComponentName(functionName) || isHook(functionName)) {\n            return true;\n          }\n        }\n\n        node = node.parent;\n      }\n\n      return false;\n    }\n\n    var RuleOfHooks = {\n      create: function (context) {\n        var codePathReactHooksMapStack = [];\n        var codePathSegmentStack = [];\n        return {\n          // Maintain code segment path stack as we traverse.\n          onCodePathSegmentStart: function (segment) {\n            return codePathSegmentStack.push(segment);\n          },\n          onCodePathSegmentEnd: function () {\n            return codePathSegmentStack.pop();\n          },\n          // Maintain code path stack as we traverse.\n          onCodePathStart: function () {\n            return codePathReactHooksMapStack.push(new Map());\n          },\n          // Process our code path.\n          //\n          // Everything is ok if all React Hooks are both reachable from the initial\n          // segment and reachable from every final segment.\n          onCodePathEnd: function (codePath, codePathNode) {\n            var reactHooksMap = codePathReactHooksMapStack.pop();\n\n            if (reactHooksMap.size === 0) {\n              return;\n            } // All of the segments which are cyclic are recorded in this set.\n\n\n            var cyclic = new Set();\n            /**\n             * Count the number of code paths from the start of the function to this\n             * segment. For example:\n             *\n             * ```js\n             * function MyComponent() {\n             *   if (condition) {\n             *     // Segment 1\n             *   } else {\n             *     // Segment 2\n             *   }\n             *   // Segment 3\n             * }\n             * ```\n             *\n             * Segments 1 and 2 have one path to the beginning of `MyComponent` and\n             * segment 3 has two paths to the beginning of `MyComponent` since we\n             * could have either taken the path of segment 1 or segment 2.\n             *\n             * Populates `cyclic` with cyclic segments.\n             */\n\n            function countPathsFromStart(segment) {\n              var cache = countPathsFromStart.cache;\n              var paths = cache.get(segment.id); // If `paths` is null then we've found a cycle! Add it to `cyclic` and\n              // any other segments which are a part of this cycle.\n\n              if (paths === null) {\n                if (cyclic.has(segment.id)) {\n                  return 0;\n                } else {\n                  cyclic.add(segment.id);\n                  var _iteratorNormalCompletion = true;\n                  var _didIteratorError = false;\n                  var _iteratorError = undefined;\n\n                  try {\n                    for (var _iterator = segment.prevSegments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                      var prevSegment = _step.value;\n                      countPathsFromStart(prevSegment);\n                    }\n                  } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion && _iterator.return != null) {\n                        _iterator.return();\n                      }\n                    } finally {\n                      if (_didIteratorError) {\n                        throw _iteratorError;\n                      }\n                    }\n                  }\n\n                  return 0;\n                }\n              } // We have a cached `paths`. Return it.\n\n\n              if (paths !== undefined) {\n                return paths;\n              } // Compute `paths` and cache it. Guarding against cycles.\n\n\n              cache.set(segment.id, null);\n\n              if (codePath.thrownSegments.includes(segment)) {\n                paths = 0;\n              } else if (segment.prevSegments.length === 0) {\n                paths = 1;\n              } else {\n                paths = 0;\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                  for (var _iterator2 = segment.prevSegments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var _prevSegment = _step2.value;\n                    paths += countPathsFromStart(_prevSegment);\n                  }\n                } catch (err) {\n                  _didIteratorError2 = true;\n                  _iteratorError2 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                      _iterator2.return();\n                    }\n                  } finally {\n                    if (_didIteratorError2) {\n                      throw _iteratorError2;\n                    }\n                  }\n                }\n              } // If our segment is reachable then there should be at least one path\n              // to it from the start of our code path.\n\n\n              if (segment.reachable && paths === 0) {\n                cache.delete(segment.id);\n              } else {\n                cache.set(segment.id, paths);\n              }\n\n              return paths;\n            }\n            /**\n             * Count the number of code paths from this segment to the end of the\n             * function. For example:\n             *\n             * ```js\n             * function MyComponent() {\n             *   // Segment 1\n             *   if (condition) {\n             *     // Segment 2\n             *   } else {\n             *     // Segment 3\n             *   }\n             * }\n             * ```\n             *\n             * Segments 2 and 3 have one path to the end of `MyComponent` and\n             * segment 1 has two paths to the end of `MyComponent` since we could\n             * either take the path of segment 1 or segment 2.\n             *\n             * Populates `cyclic` with cyclic segments.\n             */\n\n\n            function countPathsToEnd(segment) {\n              var cache = countPathsToEnd.cache;\n              var paths = cache.get(segment.id); // If `paths` is null then we've found a cycle! Add it to `cyclic` and\n              // any other segments which are a part of this cycle.\n\n              if (paths === null) {\n                if (cyclic.has(segment.id)) {\n                  return 0;\n                } else {\n                  cyclic.add(segment.id);\n                  var _iteratorNormalCompletion3 = true;\n                  var _didIteratorError3 = false;\n                  var _iteratorError3 = undefined;\n\n                  try {\n                    for (var _iterator3 = segment.nextSegments[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                      var nextSegment = _step3.value;\n                      countPathsToEnd(nextSegment);\n                    }\n                  } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                        _iterator3.return();\n                      }\n                    } finally {\n                      if (_didIteratorError3) {\n                        throw _iteratorError3;\n                      }\n                    }\n                  }\n\n                  return 0;\n                }\n              } // We have a cached `paths`. Return it.\n\n\n              if (paths !== undefined) {\n                return paths;\n              } // Compute `paths` and cache it. Guarding against cycles.\n\n\n              cache.set(segment.id, null);\n\n              if (codePath.thrownSegments.includes(segment)) {\n                paths = 0;\n              } else if (segment.nextSegments.length === 0) {\n                paths = 1;\n              } else {\n                paths = 0;\n                var _iteratorNormalCompletion4 = true;\n                var _didIteratorError4 = false;\n                var _iteratorError4 = undefined;\n\n                try {\n                  for (var _iterator4 = segment.nextSegments[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var _nextSegment = _step4.value;\n                    paths += countPathsToEnd(_nextSegment);\n                  }\n                } catch (err) {\n                  _didIteratorError4 = true;\n                  _iteratorError4 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                      _iterator4.return();\n                    }\n                  } finally {\n                    if (_didIteratorError4) {\n                      throw _iteratorError4;\n                    }\n                  }\n                }\n              }\n\n              cache.set(segment.id, paths);\n              return paths;\n            }\n            /**\n             * Gets the shortest path length to the start of a code path.\n             * For example:\n             *\n             * ```js\n             * function MyComponent() {\n             *   if (condition) {\n             *     // Segment 1\n             *   }\n             *   // Segment 2\n             * }\n             * ```\n             *\n             * There is only one path from segment 1 to the code path start. Its\n             * length is one so that is the shortest path.\n             *\n             * There are two paths from segment 2 to the code path start. One\n             * through segment 1 with a length of two and another directly to the\n             * start with a length of one. The shortest path has a length of one\n             * so we would return that.\n             */\n\n\n            function shortestPathLengthToStart(segment) {\n              var cache = shortestPathLengthToStart.cache;\n              var length = cache.get(segment.id); // If `length` is null then we found a cycle! Return infinity since\n              // the shortest path is definitely not the one where we looped.\n\n              if (length === null) {\n                return Infinity;\n              } // We have a cached `length`. Return it.\n\n\n              if (length !== undefined) {\n                return length;\n              } // Compute `length` and cache it. Guarding against cycles.\n\n\n              cache.set(segment.id, null);\n\n              if (segment.prevSegments.length === 0) {\n                length = 1;\n              } else {\n                length = Infinity;\n                var _iteratorNormalCompletion5 = true;\n                var _didIteratorError5 = false;\n                var _iteratorError5 = undefined;\n\n                try {\n                  for (var _iterator5 = segment.prevSegments[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var prevSegment = _step5.value;\n                    var prevLength = shortestPathLengthToStart(prevSegment);\n\n                    if (prevLength < length) {\n                      length = prevLength;\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError5 = true;\n                  _iteratorError5 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                      _iterator5.return();\n                    }\n                  } finally {\n                    if (_didIteratorError5) {\n                      throw _iteratorError5;\n                    }\n                  }\n                }\n\n                length += 1;\n              }\n\n              cache.set(segment.id, length);\n              return length;\n            }\n\n            countPathsFromStart.cache = new Map();\n            countPathsToEnd.cache = new Map();\n            shortestPathLengthToStart.cache = new Map(); // Count all code paths to the end of our component/hook. Also primes\n            // the `countPathsToEnd` cache.\n\n            var allPathsFromStartToEnd = countPathsToEnd(codePath.initialSegment); // Gets the function name for our code path. If the function name is\n            // `undefined` then we know either that we have an anonymous function\n            // expression or our code path is not in a function. In both cases we\n            // will want to error since neither are React function components or\n            // hook functions.\n\n            var codePathFunctionName = getFunctionName(codePathNode); // This is a valid code path for React hooks if we are directly in a React\n            // function component or we are in a hook function.\n\n            var isSomewhereInsideComponentOrHook = isInsideComponentOrHook(codePathNode);\n            var isDirectlyInsideComponentOrHook = codePathFunctionName ? isComponentName(codePathFunctionName) || isHook(codePathFunctionName) : false; // Compute the earliest finalizer level using information from the\n            // cache. We expect all reachable final segments to have a cache entry\n            // after calling `visitSegment()`.\n\n            var shortestFinalPathLength = Infinity;\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n              for (var _iterator6 = codePath.finalSegments[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                var finalSegment = _step6.value;\n\n                if (!finalSegment.reachable) {\n                  continue;\n                }\n\n                var length = shortestPathLengthToStart(finalSegment);\n\n                if (length < shortestFinalPathLength) {\n                  shortestFinalPathLength = length;\n                }\n              } // Make sure all React Hooks pass our lint invariants. Log warnings\n              // if not.\n\n            } catch (err) {\n              _didIteratorError6 = true;\n              _iteratorError6 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                  _iterator6.return();\n                }\n              } finally {\n                if (_didIteratorError6) {\n                  throw _iteratorError6;\n                }\n              }\n            }\n\n            var _iteratorNormalCompletion7 = true;\n            var _didIteratorError7 = false;\n            var _iteratorError7 = undefined;\n\n            try {\n              for (var _iterator7 = reactHooksMap[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                var _step7$value = _step7.value,\n                    segment = _step7$value[0],\n                    reactHooks = _step7$value[1]; // NOTE: We could report here that the hook is not reachable, but\n                // that would be redundant with more general \"no unreachable\"\n                // lint rules.\n\n                if (!segment.reachable) {\n                  continue;\n                } // If there are any final segments with a shorter path to start then\n                // we possibly have an early return.\n                //\n                // If our segment is a final segment itself then siblings could\n                // possibly be early returns.\n\n\n                var possiblyHasEarlyReturn = segment.nextSegments.length === 0 ? shortestFinalPathLength <= shortestPathLengthToStart(segment) : shortestFinalPathLength < shortestPathLengthToStart(segment); // Count all the paths from the start of our code path to the end of\n                // our code path that go _through_ this segment. The critical piece\n                // of this is _through_. If we just call `countPathsToEnd(segment)`\n                // then we neglect that we may have gone through multiple paths to get\n                // to this point! Consider:\n                //\n                // ```js\n                // function MyComponent() {\n                //   if (a) {\n                //     // Segment 1\n                //   } else {\n                //     // Segment 2\n                //   }\n                //   // Segment 3\n                //   if (b) {\n                //     // Segment 4\n                //   } else {\n                //     // Segment 5\n                //   }\n                // }\n                // ```\n                //\n                // In this component we have four code paths:\n                //\n                // 1. `a = true; b = true`\n                // 2. `a = true; b = false`\n                // 3. `a = false; b = true`\n                // 4. `a = false; b = false`\n                //\n                // From segment 3 there are two code paths to the end through segment\n                // 4 and segment 5. However, we took two paths to get here through\n                // segment 1 and segment 2.\n                //\n                // If we multiply the paths from start (two) by the paths to end (two)\n                // for segment 3 we get four. Which is our desired count.\n\n                var pathsFromStartToEnd = countPathsFromStart(segment) * countPathsToEnd(segment); // Is this hook a part of a cyclic segment?\n\n                var cycled = cyclic.has(segment.id);\n                var _iteratorNormalCompletion8 = true;\n                var _didIteratorError8 = false;\n                var _iteratorError8 = undefined;\n\n                try {\n                  for (var _iterator8 = reactHooks[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                    var hook = _step8.value; // Report an error if a hook may be called more then once.\n\n                    if (cycled) {\n                      context.report({\n                        node: hook,\n                        message: \"React Hook \\\"\" + context.getSource(hook) + \"\\\" may be executed \" + 'more than once. Possibly because it is called in a loop. ' + 'React Hooks must be called in the exact same order in ' + 'every component render.'\n                      });\n                    } // If this is not a valid code path for React hooks then we need to\n                    // log a warning for every hook in this code path.\n                    //\n                    // Pick a special message depending on the scope this hook was\n                    // called in.\n\n\n                    if (isDirectlyInsideComponentOrHook) {\n                      // Report an error if a hook does not reach all finalizing code\n                      // path segments.\n                      //\n                      // Special case when we think there might be an early return.\n                      if (!cycled && pathsFromStartToEnd !== allPathsFromStartToEnd) {\n                        var message = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" is called \" + 'conditionally. React Hooks must be called in the exact ' + 'same order in every component render.' + (possiblyHasEarlyReturn ? ' Did you accidentally call a React Hook after an' + ' early return?' : '');\n                        context.report({\n                          node: hook,\n                          message: message\n                        });\n                      }\n                    } else if (codePathNode.parent && (codePathNode.parent.type === 'MethodDefinition' || codePathNode.parent.type === 'ClassProperty') && codePathNode.parent.value === codePathNode) {// Ignore class methods for now because they produce too many\n                      // false positives due to feature flag checks. We're less\n                      // sensitive to them in classes because hooks would produce\n                      // runtime errors in classes anyway, and because a use*()\n                      // call in a class, if it works, is unambiguously *not* a hook.\n                    } else if (codePathFunctionName) {\n                      // Custom message if we found an invalid function name.\n                      var _message = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" is called in \" + (\"function \\\"\" + context.getSource(codePathFunctionName) + \"\\\" \") + 'that is neither a React function component nor a custom ' + 'React Hook function.';\n\n                      context.report({\n                        node: hook,\n                        message: _message\n                      });\n                    } else if (codePathNode.type === 'Program') {\n                      // These are dangerous if you have inline requires enabled.\n                      var _message2 = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" cannot be called \" + 'at the top level. React Hooks must be called in a ' + 'React function component or a custom React Hook function.';\n\n                      context.report({\n                        node: hook,\n                        message: _message2\n                      });\n                    } else {\n                      // Assume in all other cases the user called a hook in some\n                      // random function callback. This should usually be true for\n                      // anonymous function expressions. Hopefully this is clarifying\n                      // enough in the common case that the incorrect message in\n                      // uncommon cases doesn't matter.\n                      if (isSomewhereInsideComponentOrHook) {\n                        var _message3 = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" cannot be called \" + 'inside a callback. React Hooks must be called in a ' + 'React function component or a custom React Hook function.';\n\n                        context.report({\n                          node: hook,\n                          message: _message3\n                        });\n                      }\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError8 = true;\n                  _iteratorError8 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n                      _iterator8.return();\n                    }\n                  } finally {\n                    if (_didIteratorError8) {\n                      throw _iteratorError8;\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _didIteratorError7 = true;\n              _iteratorError7 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n                  _iterator7.return();\n                }\n              } finally {\n                if (_didIteratorError7) {\n                  throw _iteratorError7;\n                }\n              }\n            }\n          },\n          // Missed opportunity...We could visit all `Identifier`s instead of all\n          // `CallExpression`s and check that _every use_ of a hook name is valid.\n          // But that gets complicated and enters type-system territory, so we're\n          // only being strict about hook calls for now.\n          CallExpression: function (node) {\n            if (isHook(node.callee)) {\n              // Add the hook node to a map keyed by the code path segment. We will\n              // do full code path analysis at the end of our code path.\n              var reactHooksMap = last(codePathReactHooksMapStack);\n              var codePathSegment = last(codePathSegmentStack);\n              var reactHooks = reactHooksMap.get(codePathSegment);\n\n              if (!reactHooks) {\n                reactHooks = [];\n                reactHooksMap.set(codePathSegment, reactHooks);\n              }\n\n              reactHooks.push(node.callee);\n            }\n          }\n        };\n      }\n    };\n    /**\n     * Gets the static name of a function AST node. For function declarations it is\n     * easy. For anonymous function expressions it is much harder. If you search for\n     * `IsAnonymousFunctionDefinition()` in the ECMAScript spec you'll find places\n     * where JS gives anonymous function expressions names. We roughly detect the\n     * same AST nodes with some exceptions to better fit our usecase.\n     */\n\n    function getFunctionName(node) {\n      if (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' && node.id) {\n        // function useHook() {}\n        // const whatever = function useHook() {};\n        //\n        // Function declaration or function expression names win over any\n        // assignment statements or other renames.\n        return node.id;\n      } else if (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') {\n        if (node.parent.type === 'VariableDeclarator' && node.parent.init === node) {\n          // const useHook = () => {};\n          return node.parent.id;\n        } else if (node.parent.type === 'AssignmentExpression' && node.parent.right === node && node.parent.operator === '=') {\n          // useHook = () => {};\n          return node.parent.left;\n        } else if (node.parent.type === 'Property' && node.parent.value === node && !node.parent.computed) {\n          // {useHook: () => {}}\n          // {useHook() {}}\n          return node.parent.key; // NOTE: We could also support `ClassProperty` and `MethodDefinition`\n          // here to be pedantic. However, hooks in a class are an anti-pattern. So\n          // we don't allow it to error early.\n          //\n          // class {useHook = () => {}}\n          // class {useHook() {}}\n        } else if (node.parent.type === 'AssignmentPattern' && node.parent.right === node && !node.parent.computed) {\n          // const {useHook = () => {}} = {};\n          // ({useHook = () => {}} = {});\n          //\n          // Kinda clowny, but we'd said we'd follow spec convention for\n          // `IsAnonymousFunctionDefinition()` usage.\n          return node.parent.left;\n        } else {\n          return undefined;\n        }\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Convenience function for peeking the last item in a stack.\n     */\n\n\n    function last(array) {\n      return array[array.length - 1];\n    }\n    /* eslint-disable no-for-of-loops/no-for-of-loops */\n\n\n    var ExhaustiveDeps = {\n      meta: {\n        fixable: 'code',\n        schema: [{\n          type: 'object',\n          additionalProperties: false,\n          properties: {\n            additionalHooks: {\n              type: 'string'\n            }\n          }\n        }]\n      },\n      create: function (context) {\n        // Parse the `additionalHooks` regex.\n        var additionalHooks = context.options && context.options[0] && context.options[0].additionalHooks ? new RegExp(context.options[0].additionalHooks) : undefined;\n        var options = {\n          additionalHooks: additionalHooks\n        }; // Should be shared between visitors.\n\n        var setStateCallSites = new WeakMap();\n        var stateVariables = new WeakSet();\n        var staticKnownValueCache = new WeakMap();\n        var functionWithoutCapturedValueCache = new WeakMap();\n\n        function memoizeWithWeakMap(fn, map) {\n          return function (arg) {\n            if (map.has(arg)) {\n              // to verify cache hits:\n              // console.log(arg.name)\n              return map.get(arg);\n            }\n\n            var result = fn(arg);\n            map.set(arg, result);\n            return result;\n          };\n        }\n\n        return {\n          FunctionExpression: visitFunctionExpression,\n          ArrowFunctionExpression: visitFunctionExpression\n        };\n        /**\n         * Visitor for both function expressions and arrow function expressions.\n         */\n\n        function visitFunctionExpression(node) {\n          // We only want to lint nodes which are reactive hook callbacks.\n          if (node.type !== 'FunctionExpression' && node.type !== 'ArrowFunctionExpression' || node.parent.type !== 'CallExpression') {\n            return;\n          }\n\n          var callbackIndex = getReactiveHookCallbackIndex(node.parent.callee, options);\n\n          if (node.parent.arguments[callbackIndex] !== node) {\n            return;\n          } // Get the reactive hook node.\n\n\n          var reactiveHook = node.parent.callee;\n          var reactiveHookName = getNodeWithoutReactNamespace(reactiveHook).name;\n          var isEffect = reactiveHookName.endsWith('Effect'); // Get the declared dependencies for this reactive hook. If there is no\n          // second argument then the reactive callback will re-run on every render.\n          // So no need to check for dependency inclusion.\n\n          var depsIndex = callbackIndex + 1;\n          var declaredDependenciesNode = node.parent.arguments[depsIndex];\n\n          if (!declaredDependenciesNode && !isEffect) {\n            // These are only used for optimization.\n            if (reactiveHookName === 'useMemo' || reactiveHookName === 'useCallback') {\n              // TODO: Can this have an autofix?\n              context.report({\n                node: node.parent.callee,\n                message: \"React Hook \" + reactiveHookName + \" does nothing when called with \" + \"only one argument. Did you forget to pass an array of \" + \"dependencies?\"\n              });\n            }\n\n            return;\n          }\n\n          if (isEffect && node.async) {\n            context.report({\n              node: node,\n              message: \"Effect callbacks are synchronous to prevent race conditions. \" + \"Put the async function inside:\\n\\n\" + 'useEffect(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + \"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\" + 'Learn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching'\n            });\n          } // Get the current scope.\n\n\n          var scope = context.getScope(); // Find all our \"pure scopes\". On every re-render of a component these\n          // pure scopes may have changes to the variables declared within. So all\n          // variables used in our reactive hook callback but declared in a pure\n          // scope need to be listed as dependencies of our reactive hook callback.\n          //\n          // According to the rules of React you can't read a mutable value in pure\n          // scope. We can't enforce this in a lint so we trust that all variables\n          // declared outside of pure scope are indeed frozen.\n\n          var pureScopes = new Set();\n          var componentScope = null;\n          {\n            var currentScope = scope.upper;\n\n            while (currentScope) {\n              pureScopes.add(currentScope);\n\n              if (currentScope.type === 'function') {\n                break;\n              }\n\n              currentScope = currentScope.upper;\n            } // If there is no parent function scope then there are no pure scopes.\n            // The ones we've collected so far are incorrect. So don't continue with\n            // the lint.\n\n\n            if (!currentScope) {\n              return;\n            }\n\n            componentScope = currentScope;\n          } // Next we'll define a few helpers that helps us\n          // tell if some values don't have to be declared as deps.\n          // Some are known to be static based on Hook calls.\n          // const [state, setState] = useState() / React.useState()\n          //               ^^^ true for this reference\n          // const [state, dispatch] = useReducer() / React.useReducer()\n          //               ^^^ true for this reference\n          // const ref = useRef()\n          //       ^^^ true for this reference\n          // False for everything else.\n\n          function isStaticKnownHookValue(resolved) {\n            if (!Array.isArray(resolved.defs)) {\n              return false;\n            }\n\n            var def = resolved.defs[0];\n\n            if (def == null) {\n              return false;\n            } // Look for `let stuff = ...`\n\n\n            if (def.node.type !== 'VariableDeclarator') {\n              return false;\n            }\n\n            var init = def.node.init;\n\n            if (init == null) {\n              return false;\n            } // Detect primitive constants\n            // const foo = 42\n\n\n            var declaration = def.node.parent;\n\n            if (declaration == null) {\n              // This might happen if variable is declared after the callback.\n              // In that case ESLint won't set up .parent refs.\n              // So we'll set them up manually.\n              fastFindReferenceWithParent(componentScope.block, def.node.id);\n              declaration = def.node.parent;\n\n              if (declaration == null) {\n                return false;\n              }\n            }\n\n            if (declaration.kind === 'const' && init.type === 'Literal' && (typeof init.value === 'string' || typeof init.value === 'number' || init.value === null)) {\n              // Definitely static\n              return true;\n            } // Detect known Hook calls\n            // const [_, setState] = useState()\n\n\n            if (init.type !== 'CallExpression') {\n              return false;\n            }\n\n            var callee = init.callee; // Step into `= React.something` initializer.\n\n            if (callee.type === 'MemberExpression' && callee.object.name === 'React' && callee.property != null && !callee.computed) {\n              callee = callee.property;\n            }\n\n            if (callee.type !== 'Identifier') {\n              return false;\n            }\n\n            var id = def.node.id;\n            var _callee = callee,\n                name = _callee.name;\n\n            if (name === 'useRef' && id.type === 'Identifier') {\n              // useRef() return value is static.\n              return true;\n            } else if (name === 'useState' || name === 'useReducer') {\n              // Only consider second value in initializing tuple static.\n              if (id.type === 'ArrayPattern' && id.elements.length === 2 && Array.isArray(resolved.identifiers)) {\n                // Is second tuple value the same reference we're checking?\n                if (id.elements[1] === resolved.identifiers[0]) {\n                  if (name === 'useState') {\n                    var references = resolved.references;\n\n                    for (var i = 0; i < references.length; i++) {\n                      setStateCallSites.set(references[i].identifier, id.elements[0]);\n                    }\n                  } // Setter is static.\n\n\n                  return true;\n                } else if (id.elements[0] === resolved.identifiers[0]) {\n                  if (name === 'useState') {\n                    var _references = resolved.references;\n\n                    for (var _i = 0; _i < _references.length; _i++) {\n                      stateVariables.add(_references[_i].identifier);\n                    }\n                  } // State variable itself is dynamic.\n\n\n                  return false;\n                }\n              }\n            } // By default assume it's dynamic.\n\n\n            return false;\n          } // Some are just functions that don't reference anything dynamic.\n\n\n          function isFunctionWithoutCapturedValues(resolved) {\n            if (!Array.isArray(resolved.defs)) {\n              return false;\n            }\n\n            var def = resolved.defs[0];\n\n            if (def == null) {\n              return false;\n            }\n\n            if (def.node == null || def.node.id == null) {\n              return false;\n            } // Search the direct component subscopes for\n            // top-level function definitions matching this reference.\n\n\n            var fnNode = def.node;\n            var childScopes = componentScope.childScopes;\n            var fnScope = null;\n            var i;\n\n            for (i = 0; i < childScopes.length; i++) {\n              var childScope = childScopes[i];\n              var childScopeBlock = childScope.block;\n\n              if ( // function handleChange() {}\n              fnNode.type === 'FunctionDeclaration' && childScopeBlock === fnNode || // const handleChange = () => {}\n              // const handleChange = function() {}\n              fnNode.type === 'VariableDeclarator' && childScopeBlock.parent === fnNode) {\n                // Found it!\n                fnScope = childScope;\n                break;\n              }\n            }\n\n            if (fnScope == null) {\n              return false;\n            } // Does this function capture any values\n            // that are in pure scopes (aka render)?\n\n\n            for (i = 0; i < fnScope.through.length; i++) {\n              var ref = fnScope.through[i];\n\n              if (ref.resolved == null) {\n                continue;\n              }\n\n              if (pureScopes.has(ref.resolved.scope) && // Static values are fine though,\n              // although we won't check functions deeper.\n              !memoizedIsStaticKnownHookValue(ref.resolved)) {\n                return false;\n              }\n            } // If we got here, this function doesn't capture anything\n            // from render--or everything it captures is known static.\n\n\n            return true;\n          } // Remember such values. Avoid re-running extra checks on them.\n\n\n          var memoizedIsStaticKnownHookValue = memoizeWithWeakMap(isStaticKnownHookValue, staticKnownValueCache);\n          var memoizedIsFunctionWithoutCapturedValues = memoizeWithWeakMap(isFunctionWithoutCapturedValues, functionWithoutCapturedValueCache); // These are usually mistaken. Collect them.\n\n          var currentRefsInEffectCleanup = new Map(); // Is this reference inside a cleanup function for this effect node?\n          // We can check by traversing scopes upwards  from the reference, and checking\n          // if the last \"return () => \" we encounter is located directly inside the effect.\n\n          function isInsideEffectCleanup(reference) {\n            var curScope = reference.from;\n            var isInReturnedFunction = false;\n\n            while (curScope.block !== node) {\n              if (curScope.type === 'function') {\n                isInReturnedFunction = curScope.block.parent != null && curScope.block.parent.type === 'ReturnStatement';\n              }\n\n              curScope = curScope.upper;\n            }\n\n            return isInReturnedFunction;\n          } // Get dependencies from all our resolved references in pure scopes.\n          // Key is dependency string, value is whether it's static.\n\n\n          var dependencies = new Map();\n          gatherDependenciesRecursively(scope);\n\n          function gatherDependenciesRecursively(currentScope) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = currentScope.references[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var reference = _step.value; // If this reference is not resolved or it is not declared in a pure\n                // scope then we don't care about this reference.\n\n                if (!reference.resolved) {\n                  continue;\n                }\n\n                if (!pureScopes.has(reference.resolved.scope)) {\n                  continue;\n                } // Narrow the scope of a dependency if it is, say, a member expression.\n                // Then normalize the narrowed dependency.\n\n\n                var referenceNode = fastFindReferenceWithParent(node, reference.identifier);\n                var dependencyNode = getDependency(referenceNode);\n                var dependency = toPropertyAccessString(dependencyNode); // Accessing ref.current inside effect cleanup is bad.\n\n                if ( // We're in an effect...\n                isEffect && // ... and this look like accessing .current...\n                dependencyNode.type === 'Identifier' && dependencyNode.parent.type === 'MemberExpression' && !dependencyNode.parent.computed && dependencyNode.parent.property.type === 'Identifier' && dependencyNode.parent.property.name === 'current' && // ...in a cleanup function or below...\n                isInsideEffectCleanup(reference)) {\n                  currentRefsInEffectCleanup.set(dependency, {\n                    reference: reference,\n                    dependencyNode: dependencyNode\n                  });\n                }\n\n                var def = reference.resolved.defs[0];\n\n                if (def == null) {\n                  continue;\n                } // Ignore references to the function itself as it's not defined yet.\n\n\n                if (def.node != null && def.node.init === node.parent) {\n                  continue;\n                } // Ignore Flow type parameters\n\n\n                if (def.type === 'TypeParameter') {\n                  continue;\n                } // Add the dependency to a map so we can make sure it is referenced\n                // again in our dependencies array. Remember whether it's static.\n\n\n                if (!dependencies.has(dependency)) {\n                  var resolved = reference.resolved;\n                  var isStatic = memoizedIsStaticKnownHookValue(resolved) || memoizedIsFunctionWithoutCapturedValues(resolved);\n                  dependencies.set(dependency, {\n                    isStatic: isStatic,\n                    references: [reference]\n                  });\n                } else {\n                  dependencies.get(dependency).references.push(reference);\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = currentScope.childScopes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var childScope = _step2.value;\n                gatherDependenciesRecursively(childScope);\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          } // Warn about accessing .current in cleanup effects.\n\n\n          currentRefsInEffectCleanup.forEach(function (_ref, dependency) {\n            var reference = _ref.reference,\n                dependencyNode = _ref.dependencyNode;\n            var references = reference.resolved.references; // Is React managing this ref or us?\n            // Let's see if we can find a .current assignment.\n\n            var foundCurrentAssignment = false;\n\n            for (var i = 0; i < references.length; i++) {\n              var identifier = references[i].identifier;\n              var parent = identifier.parent;\n\n              if (parent != null && // ref.current\n              parent.type === 'MemberExpression' && !parent.computed && parent.property.type === 'Identifier' && parent.property.name === 'current' && // ref.current = <something>\n              parent.parent.type === 'AssignmentExpression' && parent.parent.left === parent) {\n                foundCurrentAssignment = true;\n                break;\n              }\n            } // We only want to warn about React-managed refs.\n\n\n            if (foundCurrentAssignment) {\n              return;\n            }\n\n            context.report({\n              node: dependencyNode.parent.property,\n              message: \"The ref value '\" + dependency + \".current' will likely have \" + \"changed by the time this effect cleanup function runs. If \" + \"this ref points to a node rendered by React, copy \" + (\"'\" + dependency + \".current' to a variable inside the effect, and \") + \"use that variable in the cleanup function.\"\n            });\n          }); // Warn about assigning to variables in the outer scope.\n          // Those are usually bugs.\n\n          var staleAssignments = new Set();\n\n          function reportStaleAssignment(writeExpr, key) {\n            if (staleAssignments.has(key)) {\n              return;\n            }\n\n            staleAssignments.add(key);\n            context.report({\n              node: writeExpr,\n              message: \"Assignments to the '\" + key + \"' variable from inside React Hook \" + (context.getSource(reactiveHook) + \" will be lost after each \") + \"render. To preserve the value over time, store it in a useRef \" + \"Hook and keep the mutable value in the '.current' property. \" + \"Otherwise, you can move this variable directly inside \" + (context.getSource(reactiveHook) + \".\")\n            });\n          } // Remember which deps are optional and report bad usage first.\n\n\n          var optionalDependencies = new Set();\n          dependencies.forEach(function (_ref2, key) {\n            var isStatic = _ref2.isStatic,\n                references = _ref2.references;\n\n            if (isStatic) {\n              optionalDependencies.add(key);\n            }\n\n            references.forEach(function (reference) {\n              if (reference.writeExpr) {\n                reportStaleAssignment(reference.writeExpr, key);\n              }\n            });\n          });\n\n          if (staleAssignments.size > 0) {\n            // The intent isn't clear so we'll wait until you fix those first.\n            return;\n          }\n\n          if (!declaredDependenciesNode) {\n            // Check if there are any top-level setState() calls.\n            // Those tend to lead to infinite loops.\n            var setStateInsideEffectWithoutDeps = null;\n            dependencies.forEach(function (_ref3, key) {\n              var isStatic = _ref3.isStatic,\n                  references = _ref3.references;\n\n              if (setStateInsideEffectWithoutDeps) {\n                return;\n              }\n\n              references.forEach(function (reference) {\n                if (setStateInsideEffectWithoutDeps) {\n                  return;\n                }\n\n                var id = reference.identifier;\n                var isSetState = setStateCallSites.has(id);\n\n                if (!isSetState) {\n                  return;\n                }\n\n                var fnScope = reference.from;\n\n                while (fnScope.type !== 'function') {\n                  fnScope = fnScope.upper;\n                }\n\n                var isDirectlyInsideEffect = fnScope.block === node;\n\n                if (isDirectlyInsideEffect) {\n                  // TODO: we could potentially ignore early returns.\n                  setStateInsideEffectWithoutDeps = key;\n                }\n              });\n            });\n\n            if (setStateInsideEffectWithoutDeps) {\n              var _collectRecommendatio = collectRecommendations({\n                dependencies: dependencies,\n                declaredDependencies: [],\n                optionalDependencies: optionalDependencies,\n                externalDependencies: new Set(),\n                isEffect: true\n              }),\n                  _suggestedDependencies = _collectRecommendatio.suggestedDependencies;\n\n              context.report({\n                node: node.parent.callee,\n                message: \"React Hook \" + reactiveHookName + \" contains a call to '\" + setStateInsideEffectWithoutDeps + \"'. \" + \"Without a list of dependencies, this can lead to an infinite chain of updates. \" + \"To fix this, pass [\" + _suggestedDependencies.join(', ') + (\"] as a second argument to the \" + reactiveHookName + \" Hook.\"),\n                fix: function (fixer) {\n                  return fixer.insertTextAfter(node, \", [\" + _suggestedDependencies.join(', ') + \"]\");\n                }\n              });\n            }\n\n            return;\n          }\n\n          var declaredDependencies = [];\n          var externalDependencies = new Set();\n\n          if (declaredDependenciesNode.type !== 'ArrayExpression') {\n            // If the declared dependencies are not an array expression then we\n            // can't verify that the user provided the correct dependencies. Tell\n            // the user this in an error.\n            context.report({\n              node: declaredDependenciesNode,\n              message: \"React Hook \" + context.getSource(reactiveHook) + \" was passed a \" + 'dependency list that is not an array literal. This means we ' + \"can't statically verify whether you've passed the correct \" + 'dependencies.'\n            });\n          } else {\n            declaredDependenciesNode.elements.forEach(function (declaredDependencyNode) {\n              // Skip elided elements.\n              if (declaredDependencyNode === null) {\n                return;\n              } // If we see a spread element then add a special warning.\n\n\n              if (declaredDependencyNode.type === 'SpreadElement') {\n                context.report({\n                  node: declaredDependencyNode,\n                  message: \"React Hook \" + context.getSource(reactiveHook) + \" has a spread \" + \"element in its dependency array. This means we can't \" + \"statically verify whether you've passed the \" + 'correct dependencies.'\n                });\n                return;\n              } // Try to normalize the declared dependency. If we can't then an error\n              // will be thrown. We will catch that error and report an error.\n\n\n              var declaredDependency;\n\n              try {\n                declaredDependency = toPropertyAccessString(declaredDependencyNode);\n              } catch (error) {\n                if (/Unsupported node type/.test(error.message)) {\n                  if (declaredDependencyNode.type === 'Literal') {\n                    if (dependencies.has(declaredDependencyNode.value)) {\n                      context.report({\n                        node: declaredDependencyNode,\n                        message: \"The \" + declaredDependencyNode.raw + \" literal is not a valid dependency \" + \"because it never changes. \" + (\"Did you mean to include \" + declaredDependencyNode.value + \" in the array instead?\")\n                      });\n                    } else {\n                      context.report({\n                        node: declaredDependencyNode,\n                        message: \"The \" + declaredDependencyNode.raw + \" literal is not a valid dependency \" + 'because it never changes. You can safely remove it.'\n                      });\n                    }\n                  } else {\n                    context.report({\n                      node: declaredDependencyNode,\n                      message: \"React Hook \" + context.getSource(reactiveHook) + \" has a \" + \"complex expression in the dependency array. \" + 'Extract it to a separate variable so it can be statically checked.'\n                    });\n                  }\n\n                  return;\n                } else {\n                  throw error;\n                }\n              }\n\n              var maybeID = declaredDependencyNode;\n\n              while (maybeID.type === 'MemberExpression') {\n                maybeID = maybeID.object;\n              }\n\n              var isDeclaredInComponent = !componentScope.through.some(function (ref) {\n                return ref.identifier === maybeID;\n              }); // Add the dependency to our declared dependency map.\n\n              declaredDependencies.push({\n                key: declaredDependency,\n                node: declaredDependencyNode\n              });\n\n              if (!isDeclaredInComponent) {\n                externalDependencies.add(declaredDependency);\n              }\n            });\n          }\n\n          var _collectRecommendatio2 = collectRecommendations({\n            dependencies: dependencies,\n            declaredDependencies: declaredDependencies,\n            optionalDependencies: optionalDependencies,\n            externalDependencies: externalDependencies,\n            isEffect: isEffect\n          }),\n              suggestedDependencies = _collectRecommendatio2.suggestedDependencies,\n              unnecessaryDependencies = _collectRecommendatio2.unnecessaryDependencies,\n              missingDependencies = _collectRecommendatio2.missingDependencies,\n              duplicateDependencies = _collectRecommendatio2.duplicateDependencies;\n\n          var problemCount = duplicateDependencies.size + missingDependencies.size + unnecessaryDependencies.size;\n\n          if (problemCount === 0) {\n            // If nothing else to report, check if some callbacks\n            // are bare and would invalidate on every render.\n            var bareFunctions = scanForDeclaredBareFunctions({\n              declaredDependencies: declaredDependencies,\n              declaredDependenciesNode: declaredDependenciesNode,\n              componentScope: componentScope,\n              scope: scope\n            });\n            bareFunctions.forEach(function (_ref4) {\n              var fn = _ref4.fn,\n                  suggestUseCallback = _ref4.suggestUseCallback;\n              var message = \"The '\" + fn.name.name + \"' function makes the dependencies of \" + (reactiveHookName + \" Hook (at line \" + declaredDependenciesNode.loc.start.line + \") \") + \"change on every render.\";\n\n              if (suggestUseCallback) {\n                message += \" To fix this, \" + (\"wrap the '\" + fn.name.name + \"' definition into its own useCallback() Hook.\");\n              } else {\n                message += \" Move it inside the \" + reactiveHookName + \" callback. \" + (\"Alternatively, wrap the '\" + fn.name.name + \"' definition into its own useCallback() Hook.\");\n              } // TODO: What if the function needs to change on every render anyway?\n              // Should we suggest removing effect deps as an appropriate fix too?\n\n\n              context.report({\n                // TODO: Why not report this at the dependency site?\n                node: fn.node,\n                message: message,\n                fix: function (fixer) {\n                  // Only handle the simple case: arrow functions.\n                  // Wrapping function declarations can mess up hoisting.\n                  if (suggestUseCallback && fn.type === 'Variable') {\n                    return [// TODO: also add an import?\n                    fixer.insertTextBefore(fn.node.init, 'useCallback('), // TODO: ideally we'd gather deps here but it would require\n                    // restructuring the rule code. This will cause a new lint\n                    // error to appear immediately for useCallback. Note we're\n                    // not adding [] because would that changes semantics.\n                    fixer.insertTextAfter(fn.node.init, ')')];\n                  }\n                }\n              });\n            });\n            return;\n          } // If we're going to report a missing dependency,\n          // we might as well recalculate the list ignoring\n          // the currently specified deps. This can result\n          // in some extra deduplication. We can't do this\n          // for effects though because those have legit\n          // use cases for over-specifying deps.\n\n\n          if (!isEffect && missingDependencies.size > 0) {\n            suggestedDependencies = collectRecommendations({\n              dependencies: dependencies,\n              declaredDependencies: [],\n              // Pretend we don't know\n              optionalDependencies: optionalDependencies,\n              externalDependencies: externalDependencies,\n              isEffect: isEffect\n            }).suggestedDependencies;\n          } // Alphabetize the suggestions, but only if deps were already alphabetized.\n\n\n          function areDeclaredDepsAlphabetized() {\n            if (declaredDependencies.length === 0) {\n              return true;\n            }\n\n            var declaredDepKeys = declaredDependencies.map(function (dep) {\n              return dep.key;\n            });\n            var sortedDeclaredDepKeys = declaredDepKeys.slice().sort();\n            return declaredDepKeys.join(',') === sortedDeclaredDepKeys.join(',');\n          }\n\n          if (areDeclaredDepsAlphabetized()) {\n            suggestedDependencies.sort();\n          }\n\n          function getWarningMessage(deps, singlePrefix, label, fixVerb) {\n            if (deps.size === 0) {\n              return null;\n            }\n\n            return (deps.size > 1 ? '' : singlePrefix + ' ') + label + ' ' + (deps.size > 1 ? 'dependencies' : 'dependency') + ': ' + joinEnglish(Array.from(deps).sort().map(function (name) {\n              return \"'\" + name + \"'\";\n            })) + (\". Either \" + fixVerb + \" \" + (deps.size > 1 ? 'them' : 'it') + \" or remove the dependency array.\");\n          }\n\n          var extraWarning = '';\n\n          if (unnecessaryDependencies.size > 0) {\n            var badRef = null;\n            Array.from(unnecessaryDependencies.keys()).forEach(function (key) {\n              if (badRef !== null) {\n                return;\n              }\n\n              if (key.endsWith('.current')) {\n                badRef = key;\n              }\n            });\n\n            if (badRef !== null) {\n              extraWarning = \" Mutable values like '\" + badRef + \"' aren't valid dependencies \" + \"because mutating them doesn't re-render the component.\";\n            } else if (externalDependencies.size > 0) {\n              var dep = Array.from(externalDependencies)[0]; // Don't show this warning for things that likely just got moved *inside* the callback\n              // because in that case they're clearly not referring to globals.\n\n              if (!scope.set.has(dep)) {\n                extraWarning = \" Outer scope values like '\" + dep + \"' aren't valid dependencies \" + \"because mutating them doesn't re-render the component.\";\n              }\n            }\n          } // `props.foo()` marks `props` as a dependency because it has\n          // a `this` value. This warning can be confusing.\n          // So if we're going to show it, append a clarification.\n\n\n          if (!extraWarning && missingDependencies.has('props')) {\n            var propDep = dependencies.get('props');\n\n            if (propDep == null) {\n              return;\n            }\n\n            var refs = propDep.references;\n\n            if (!Array.isArray(refs)) {\n              return;\n            }\n\n            var isPropsOnlyUsedInMembers = true;\n\n            for (var i = 0; i < refs.length; i++) {\n              var ref = refs[i];\n              var id = fastFindReferenceWithParent(componentScope.block, ref.identifier);\n\n              if (!id) {\n                isPropsOnlyUsedInMembers = false;\n                break;\n              }\n\n              var parent = id.parent;\n\n              if (parent == null) {\n                isPropsOnlyUsedInMembers = false;\n                break;\n              }\n\n              if (parent.type !== 'MemberExpression') {\n                isPropsOnlyUsedInMembers = false;\n                break;\n              }\n            }\n\n            if (isPropsOnlyUsedInMembers) {\n              extraWarning = \" However, 'props' will change when *any* prop changes, so the \" + \"preferred fix is to destructure the 'props' object outside of \" + (\"the \" + reactiveHookName + \" call and refer to those specific props \") + (\"inside \" + context.getSource(reactiveHook) + \".\");\n            }\n          }\n\n          if (!extraWarning && missingDependencies.size > 0) {\n            // See if the user is trying to avoid specifying a callable prop.\n            // This usually means they're unaware of useCallback.\n            var missingCallbackDep = null;\n            missingDependencies.forEach(function (missingDep) {\n              if (missingCallbackDep) {\n                return;\n              } // Is this a variable from top scope?\n\n\n              var topScopeRef = componentScope.set.get(missingDep);\n              var usedDep = dependencies.get(missingDep);\n\n              if (usedDep.references[0].resolved !== topScopeRef) {\n                return;\n              } // Is this a destructured prop?\n\n\n              var def = topScopeRef.defs[0];\n\n              if (def == null || def.name == null || def.type !== 'Parameter') {\n                return;\n              } // Was it called in at least one case? Then it's a function.\n\n\n              var isFunctionCall = false;\n              var id;\n\n              for (var _i2 = 0; _i2 < usedDep.references.length; _i2++) {\n                id = usedDep.references[_i2].identifier;\n\n                if (id != null && id.parent != null && id.parent.type === 'CallExpression' && id.parent.callee === id) {\n                  isFunctionCall = true;\n                  break;\n                }\n              }\n\n              if (!isFunctionCall) {\n                return;\n              } // If it's missing (i.e. in component scope) *and* it's a parameter\n              // then it is definitely coming from props destructuring.\n              // (It could also be props itself but we wouldn't be calling it then.)\n\n\n              missingCallbackDep = missingDep;\n            });\n\n            if (missingCallbackDep !== null) {\n              extraWarning = \" If '\" + missingCallbackDep + \"' changes too often, \" + \"find the parent component that defines it \" + \"and wrap that definition in useCallback.\";\n            }\n          }\n\n          if (!extraWarning && missingDependencies.size > 0) {\n            var setStateRecommendation = null;\n            missingDependencies.forEach(function (missingDep) {\n              if (setStateRecommendation !== null) {\n                return;\n              }\n\n              var usedDep = dependencies.get(missingDep);\n              var references = usedDep.references;\n              var id;\n              var maybeCall;\n\n              for (var _i3 = 0; _i3 < references.length; _i3++) {\n                id = references[_i3].identifier;\n                maybeCall = id.parent; // Try to see if we have setState(someExpr(missingDep)).\n\n                while (maybeCall != null && maybeCall !== componentScope.block) {\n                  if (maybeCall.type === 'CallExpression') {\n                    var correspondingStateVariable = setStateCallSites.get(maybeCall.callee);\n\n                    if (correspondingStateVariable != null) {\n                      if (correspondingStateVariable.name === missingDep) {\n                        // setCount(count + 1)\n                        setStateRecommendation = {\n                          missingDep: missingDep,\n                          setter: maybeCall.callee.name,\n                          form: 'updater'\n                        };\n                      } else if (stateVariables.has(id)) {\n                        // setCount(count + increment)\n                        setStateRecommendation = {\n                          missingDep: missingDep,\n                          setter: maybeCall.callee.name,\n                          form: 'reducer'\n                        };\n                      } else {\n                        var resolved = references[_i3].resolved;\n\n                        if (resolved != null) {\n                          // If it's a parameter *and* a missing dep,\n                          // it must be a prop or something inside a prop.\n                          // Therefore, recommend an inline reducer.\n                          var def = resolved.defs[0];\n\n                          if (def != null && def.type === 'Parameter') {\n                            setStateRecommendation = {\n                              missingDep: missingDep,\n                              setter: maybeCall.callee.name,\n                              form: 'inlineReducer'\n                            };\n                          }\n                        }\n                      }\n\n                      break;\n                    }\n                  }\n\n                  maybeCall = maybeCall.parent;\n                }\n\n                if (setStateRecommendation !== null) {\n                  break;\n                }\n              }\n            });\n\n            if (setStateRecommendation !== null) {\n              switch (setStateRecommendation.form) {\n                case 'reducer':\n                  extraWarning = \" You can also replace multiple useState variables with useReducer \" + (\"if '\" + setStateRecommendation.setter + \"' needs the \") + (\"current value of '\" + setStateRecommendation.missingDep + \"'.\");\n                  break;\n\n                case 'inlineReducer':\n                  extraWarning = \" If '\" + setStateRecommendation.setter + \"' needs the \" + (\"current value of '\" + setStateRecommendation.missingDep + \"', \") + \"you can also switch to useReducer instead of useState and \" + (\"read '\" + setStateRecommendation.missingDep + \"' in the reducer.\");\n                  break;\n\n                case 'updater':\n                  extraWarning = \" You can also do a functional update '\" + setStateRecommendation.setter + \"(\" + setStateRecommendation.missingDep.substring(0, 1) + \" => ...)' if you only need '\" + setStateRecommendation.missingDep + \"'\" + (\" in the '\" + setStateRecommendation.setter + \"' call.\");\n                  break;\n\n                default:\n                  throw new Error('Unknown case.');\n              }\n            }\n          }\n\n          context.report({\n            node: declaredDependenciesNode,\n            message: \"React Hook \" + context.getSource(reactiveHook) + \" has \" + ( // To avoid a long message, show the next actionable item.\n            getWarningMessage(missingDependencies, 'a', 'missing', 'include') || getWarningMessage(unnecessaryDependencies, 'an', 'unnecessary', 'exclude') || getWarningMessage(duplicateDependencies, 'a', 'duplicate', 'omit')) + extraWarning,\n            fix: function (fixer) {\n              // TODO: consider preserving the comments or formatting?\n              return fixer.replaceText(declaredDependenciesNode, \"[\" + suggestedDependencies.join(', ') + \"]\");\n            }\n          });\n        }\n      }\n    }; // The meat of the logic.\n\n    function collectRecommendations(_ref5) {\n      var dependencies = _ref5.dependencies,\n          declaredDependencies = _ref5.declaredDependencies,\n          optionalDependencies = _ref5.optionalDependencies,\n          externalDependencies = _ref5.externalDependencies,\n          isEffect = _ref5.isEffect; // Our primary data structure.\n      // It is a logical representation of property chains:\n      // `props` -> `props.foo` -> `props.foo.bar` -> `props.foo.bar.baz`\n      //         -> `props.lol`\n      //         -> `props.huh` -> `props.huh.okay`\n      //         -> `props.wow`\n      // We'll use it to mark nodes that are *used* by the programmer,\n      // and the nodes that were *declared* as deps. Then we will\n      // traverse it to learn which deps are missing or unnecessary.\n\n      var depTree = createDepTree();\n\n      function createDepTree() {\n        return {\n          isRequired: false,\n          // True if used in code\n          isSatisfiedRecursively: false,\n          // True if specified in deps\n          hasRequiredNodesBelow: false,\n          // True if something deeper is used by code\n          children: new Map() // Nodes for properties\n\n        };\n      } // Mark all required nodes first.\n      // Imagine exclamation marks next to each used deep property.\n\n\n      dependencies.forEach(function (_, key) {\n        var node = getOrCreateNodeByPath(depTree, key);\n        node.isRequired = true;\n        markAllParentsByPath(depTree, key, function (parent) {\n          parent.hasRequiredNodesBelow = true;\n        });\n      }); // Mark all satisfied nodes.\n      // Imagine checkmarks next to each declared dependency.\n\n      declaredDependencies.forEach(function (_ref6) {\n        var key = _ref6.key;\n        var node = getOrCreateNodeByPath(depTree, key);\n        node.isSatisfiedRecursively = true;\n      });\n      optionalDependencies.forEach(function (key) {\n        var node = getOrCreateNodeByPath(depTree, key);\n        node.isSatisfiedRecursively = true;\n      }); // Tree manipulation helpers.\n\n      function getOrCreateNodeByPath(rootNode, path) {\n        var keys = path.split('.');\n        var node = rootNode;\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var key = _step3.value;\n            var child = node.children.get(key);\n\n            if (!child) {\n              child = createDepTree();\n              node.children.set(key, child);\n            }\n\n            node = child;\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        return node;\n      }\n\n      function markAllParentsByPath(rootNode, path, fn) {\n        var keys = path.split('.');\n        var node = rootNode;\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = keys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var key = _step4.value;\n            var child = node.children.get(key);\n\n            if (!child) {\n              return;\n            }\n\n            fn(child);\n            node = child;\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      } // Now we can learn which dependencies are missing or necessary.\n\n\n      var missingDependencies = new Set();\n      var satisfyingDependencies = new Set();\n      scanTreeRecursively(depTree, missingDependencies, satisfyingDependencies, function (key) {\n        return key;\n      });\n\n      function scanTreeRecursively(node, missingPaths, satisfyingPaths, keyToPath) {\n        node.children.forEach(function (child, key) {\n          var path = keyToPath(key);\n\n          if (child.isSatisfiedRecursively) {\n            if (child.hasRequiredNodesBelow) {\n              // Remember this dep actually satisfied something.\n              satisfyingPaths.add(path);\n            } // It doesn't matter if there's something deeper.\n            // It would be transitively satisfied since we assume immutability.\n            // `props.foo` is enough if you read `props.foo.id`.\n\n\n            return;\n          }\n\n          if (child.isRequired) {\n            // Remember that no declared deps satisfied this node.\n            missingPaths.add(path); // If we got here, nothing in its subtree was satisfied.\n            // No need to search further.\n\n            return;\n          }\n\n          scanTreeRecursively(child, missingPaths, satisfyingPaths, function (childKey) {\n            return path + '.' + childKey;\n          });\n        });\n      } // Collect suggestions in the order they were originally specified.\n\n\n      var suggestedDependencies = [];\n      var unnecessaryDependencies = new Set();\n      var duplicateDependencies = new Set();\n      declaredDependencies.forEach(function (_ref7) {\n        var key = _ref7.key; // Does this declared dep satisfy a real need?\n\n        if (satisfyingDependencies.has(key)) {\n          if (suggestedDependencies.indexOf(key) === -1) {\n            // Good one.\n            suggestedDependencies.push(key);\n          } else {\n            // Duplicate.\n            duplicateDependencies.add(key);\n          }\n        } else {\n          if (isEffect && !key.endsWith('.current') && !externalDependencies.has(key)) {\n            // Effects are allowed extra \"unnecessary\" deps.\n            // Such as resetting scroll when ID changes.\n            // Consider them legit.\n            // The exception is ref.current which is always wrong.\n            if (suggestedDependencies.indexOf(key) === -1) {\n              suggestedDependencies.push(key);\n            }\n          } else {\n            // It's definitely not needed.\n            unnecessaryDependencies.add(key);\n          }\n        }\n      }); // Then add the missing ones at the end.\n\n      missingDependencies.forEach(function (key) {\n        suggestedDependencies.push(key);\n      });\n      return {\n        suggestedDependencies: suggestedDependencies,\n        unnecessaryDependencies: unnecessaryDependencies,\n        duplicateDependencies: duplicateDependencies,\n        missingDependencies: missingDependencies\n      };\n    } // Finds functions declared as dependencies\n    // that would invalidate on every render.\n\n\n    function scanForDeclaredBareFunctions(_ref8) {\n      var declaredDependencies = _ref8.declaredDependencies,\n          declaredDependenciesNode = _ref8.declaredDependenciesNode,\n          componentScope = _ref8.componentScope,\n          scope = _ref8.scope;\n      var bareFunctions = declaredDependencies.map(function (_ref9) {\n        var key = _ref9.key;\n        var fnRef = componentScope.set.get(key);\n\n        if (fnRef == null) {\n          return null;\n        }\n\n        var fnNode = fnRef.defs[0];\n\n        if (fnNode == null) {\n          return null;\n        } // const handleChange = function () {}\n        // const handleChange = () => {}\n\n\n        if (fnNode.type === 'Variable' && fnNode.node.type === 'VariableDeclarator' && fnNode.node.init != null && (fnNode.node.init.type === 'ArrowFunctionExpression' || fnNode.node.init.type === 'FunctionExpression')) {\n          return fnRef;\n        } // function handleChange() {}\n\n\n        if (fnNode.type === 'FunctionName' && fnNode.node.type === 'FunctionDeclaration') {\n          return fnRef;\n        }\n\n        return null;\n      }).filter(Boolean);\n\n      function isUsedOutsideOfHook(fnRef) {\n        var foundWriteExpr = false;\n\n        for (var i = 0; i < fnRef.references.length; i++) {\n          var reference = fnRef.references[i];\n\n          if (reference.writeExpr) {\n            if (foundWriteExpr) {\n              // Two writes to the same function.\n              return true;\n            } else {\n              // Ignore first write as it's not usage.\n              foundWriteExpr = true;\n              continue;\n            }\n          }\n\n          var currentScope = reference.from;\n\n          while (currentScope !== scope && currentScope != null) {\n            currentScope = currentScope.upper;\n          }\n\n          if (currentScope !== scope) {\n            // This reference is outside the Hook callback.\n            // It can only be legit if it's the deps array.\n            if (!isAncestorNodeOf(declaredDependenciesNode, reference.identifier)) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      }\n\n      return bareFunctions.map(function (fnRef) {\n        return {\n          fn: fnRef.defs[0],\n          suggestUseCallback: isUsedOutsideOfHook(fnRef)\n        };\n      });\n    }\n    /**\n     * Assuming () means the passed/returned node:\n     * (props) => (props)\n     * props.(foo) => (props.foo)\n     * props.foo.(bar) => (props).foo.bar\n     * props.foo.bar.(baz) => (props).foo.bar.baz\n     */\n\n\n    function getDependency(node) {\n      if (node.parent.type === 'MemberExpression' && node.parent.object === node && node.parent.property.name !== 'current' && !node.parent.computed && !(node.parent.parent != null && node.parent.parent.type === 'CallExpression' && node.parent.parent.callee === node.parent)) {\n        return getDependency(node.parent);\n      } else {\n        return node;\n      }\n    }\n    /**\n     * Assuming () means the passed node.\n     * (foo) -> 'foo'\n     * foo.(bar) -> 'foo.bar'\n     * foo.bar.(baz) -> 'foo.bar.baz'\n     * Otherwise throw.\n     */\n\n\n    function toPropertyAccessString(node) {\n      if (node.type === 'Identifier') {\n        return node.name;\n      } else if (node.type === 'MemberExpression' && !node.computed) {\n        var object = toPropertyAccessString(node.object);\n        var property = toPropertyAccessString(node.property);\n        return object + \".\" + property;\n      } else {\n        throw new Error(\"Unsupported node type: \" + node.type);\n      }\n    }\n\n    function getNodeWithoutReactNamespace(node, options) {\n      if (node.type === 'MemberExpression' && node.object.type === 'Identifier' && node.object.name === 'React' && node.property.type === 'Identifier' && !node.computed) {\n        return node.property;\n      }\n\n      return node;\n    } // What's the index of callback that needs to be analyzed for a given Hook?\n    // -1 if it's not a Hook we care about (e.g. useState).\n    // 0 for useEffect/useMemo/useCallback(fn).\n    // 1 for useImperativeHandle(ref, fn).\n    // For additionally configured Hooks, assume that they're like useEffect (0).\n\n\n    function getReactiveHookCallbackIndex(calleeNode, options) {\n      var node = getNodeWithoutReactNamespace(calleeNode);\n\n      if (node.type !== 'Identifier') {\n        return null;\n      }\n\n      switch (node.name) {\n        case 'useEffect':\n        case 'useLayoutEffect':\n        case 'useCallback':\n        case 'useMemo':\n          // useEffect(fn)\n          return 0;\n\n        case 'useImperativeHandle':\n          // useImperativeHandle(ref, fn)\n          return 1;\n\n        default:\n          if (node === calleeNode && options && options.additionalHooks) {\n            // Allow the user to provide a regular expression which enables the lint to\n            // target custom reactive hooks.\n            var name;\n\n            try {\n              name = toPropertyAccessString(node);\n            } catch (error) {\n              if (/Unsupported node type/.test(error.message)) {\n                return 0;\n              } else {\n                throw error;\n              }\n            }\n\n            return options.additionalHooks.test(name) ? 0 : -1;\n          } else {\n            return -1;\n          }\n\n      }\n    }\n    /**\n     * ESLint won't assign node.parent to references from context.getScope()\n     *\n     * So instead we search for the node from an ancestor assigning node.parent\n     * as we go. This mutates the AST.\n     *\n     * This traversal is:\n     * - optimized by only searching nodes with a range surrounding our target node\n     * - agnostic to AST node types, it looks for `{ type: string, ... }`\n     */\n\n\n    function fastFindReferenceWithParent(start, target) {\n      var queue = [start];\n      var item = null;\n\n      while (queue.length) {\n        item = queue.shift();\n\n        if (isSameIdentifier(item, target)) {\n          return item;\n        }\n\n        if (!isAncestorNodeOf(item, target)) {\n          continue;\n        }\n\n        for (var _i4 = 0, _Object$entries = Object.entries(item); _i4 < _Object$entries.length; _i4++) {\n          var _Object$entries$_i = _Object$entries[_i4],\n              key = _Object$entries$_i[0],\n              value = _Object$entries$_i[1];\n\n          if (key === 'parent') {\n            continue;\n          }\n\n          if (isNodeLike(value)) {\n            value.parent = item;\n            queue.push(value);\n          } else if (Array.isArray(value)) {\n            value.forEach(function (val) {\n              if (isNodeLike(val)) {\n                val.parent = item;\n                queue.push(val);\n              }\n            });\n          }\n        }\n      }\n\n      return null;\n    }\n\n    function joinEnglish(arr) {\n      var s = '';\n\n      for (var i = 0; i < arr.length; i++) {\n        s += arr[i];\n\n        if (i === 0 && arr.length === 2) {\n          s += ' and ';\n        } else if (i === arr.length - 2 && arr.length > 2) {\n          s += ', and ';\n        } else if (i < arr.length - 1) {\n          s += ', ';\n        }\n      }\n\n      return s;\n    }\n\n    function isNodeLike(val) {\n      return typeof val === 'object' && val !== null && !Array.isArray(val) && typeof val.type === 'string';\n    }\n\n    function isSameIdentifier(a, b) {\n      return a.type === 'Identifier' && a.name === b.name && a.range[0] === b.range[0] && a.range[1] === b.range[1];\n    }\n\n    function isAncestorNodeOf(a, b) {\n      return a.range[0] <= b.range[0] && a.range[1] >= b.range[1];\n    }\n\n    var rules = {\n      'rules-of-hooks': RuleOfHooks,\n      'exhaustive-deps': ExhaustiveDeps\n    };\n    var src = Object.freeze({\n      rules: rules\n    });\n    var eslintPluginReactHooks = src;\n    module.exports = eslintPluginReactHooks;\n  })();\n}","map":{"version":3,"sources":["C:/xampp/htdocs/laravel-base/node_modules/eslint-plugin-react-hooks/cjs/eslint-plugin-react-hooks.development.js"],"names":["process","env","NODE_ENV","isHookName","s","test","isHook","node","type","name","computed","property","obj","object","isComponentName","isInsideComponentOrHook","functionName","getFunctionName","parent","RuleOfHooks","create","context","codePathReactHooksMapStack","codePathSegmentStack","onCodePathSegmentStart","segment","push","onCodePathSegmentEnd","pop","onCodePathStart","Map","onCodePathEnd","codePath","codePathNode","reactHooksMap","size","cyclic","Set","countPathsFromStart","cache","paths","get","id","has","add","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","prevSegments","Symbol","iterator","_step","next","done","prevSegment","value","err","return","set","thrownSegments","includes","length","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_prevSegment","reachable","delete","countPathsToEnd","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","nextSegments","_step3","nextSegment","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","_nextSegment","shortestPathLengthToStart","Infinity","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","prevLength","allPathsFromStartToEnd","initialSegment","codePathFunctionName","isSomewhereInsideComponentOrHook","isDirectlyInsideComponentOrHook","shortestFinalPathLength","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","finalSegments","_step6","finalSegment","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_iterator7","_step7","_step7$value","reactHooks","possiblyHasEarlyReturn","pathsFromStartToEnd","cycled","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_iterator8","_step8","hook","report","message","getSource","_message","_message2","_message3","CallExpression","callee","last","codePathSegment","init","right","operator","left","key","array","ExhaustiveDeps","meta","fixable","schema","additionalProperties","properties","additionalHooks","options","RegExp","setStateCallSites","WeakMap","stateVariables","WeakSet","staticKnownValueCache","functionWithoutCapturedValueCache","memoizeWithWeakMap","fn","map","arg","result","FunctionExpression","visitFunctionExpression","ArrowFunctionExpression","callbackIndex","getReactiveHookCallbackIndex","arguments","reactiveHook","reactiveHookName","getNodeWithoutReactNamespace","isEffect","endsWith","depsIndex","declaredDependenciesNode","async","scope","getScope","pureScopes","componentScope","currentScope","upper","isStaticKnownHookValue","resolved","Array","isArray","defs","def","declaration","fastFindReferenceWithParent","block","kind","_callee","elements","identifiers","references","i","identifier","_references","_i","isFunctionWithoutCapturedValues","fnNode","childScopes","fnScope","childScope","childScopeBlock","through","ref","memoizedIsStaticKnownHookValue","memoizedIsFunctionWithoutCapturedValues","currentRefsInEffectCleanup","isInsideEffectCleanup","reference","curScope","from","isInReturnedFunction","dependencies","gatherDependenciesRecursively","referenceNode","dependencyNode","getDependency","dependency","toPropertyAccessString","isStatic","forEach","_ref","foundCurrentAssignment","staleAssignments","reportStaleAssignment","writeExpr","optionalDependencies","_ref2","setStateInsideEffectWithoutDeps","_ref3","isSetState","isDirectlyInsideEffect","_collectRecommendatio","collectRecommendations","declaredDependencies","externalDependencies","_suggestedDependencies","suggestedDependencies","join","fix","fixer","insertTextAfter","declaredDependencyNode","declaredDependency","error","raw","maybeID","isDeclaredInComponent","some","_collectRecommendatio2","unnecessaryDependencies","missingDependencies","duplicateDependencies","problemCount","bareFunctions","scanForDeclaredBareFunctions","_ref4","suggestUseCallback","loc","start","line","insertTextBefore","areDeclaredDepsAlphabetized","declaredDepKeys","dep","sortedDeclaredDepKeys","slice","sort","getWarningMessage","deps","singlePrefix","label","fixVerb","joinEnglish","extraWarning","badRef","keys","propDep","refs","isPropsOnlyUsedInMembers","missingCallbackDep","missingDep","topScopeRef","usedDep","isFunctionCall","_i2","setStateRecommendation","maybeCall","_i3","correspondingStateVariable","setter","form","substring","Error","replaceText","_ref5","depTree","createDepTree","isRequired","isSatisfiedRecursively","hasRequiredNodesBelow","children","_","getOrCreateNodeByPath","markAllParentsByPath","_ref6","rootNode","path","split","child","satisfyingDependencies","scanTreeRecursively","missingPaths","satisfyingPaths","keyToPath","childKey","_ref7","indexOf","_ref8","_ref9","fnRef","filter","Boolean","isUsedOutsideOfHook","foundWriteExpr","isAncestorNodeOf","calleeNode","target","queue","item","shift","isSameIdentifier","_i4","_Object$entries","Object","entries","_Object$entries$_i","isNodeLike","val","arr","a","b","range","rules","src","freeze","eslintPluginReactHooks","module","exports"],"mappings":"AAAA;;;;;;;;AASA;;AAIA,IAAIA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,GAAC,YAAW;AACd;AAEA;;AAEA;;;;;AAKA,aAASC,UAAT,CAAoBC,CAApB,EAAuB;AACrB,aAAO,kBAAkBC,IAAlB,CAAuBD,CAAvB,CAAP;AACD;AACD;;;;;;AAMA,aAASE,MAAT,CAAgBC,IAAhB,EAAsB;AACpB,UAAIA,IAAI,CAACC,IAAL,KAAc,YAAlB,EAAgC;AAC9B,eAAOL,UAAU,CAACI,IAAI,CAACE,IAAN,CAAjB;AACD,OAFD,MAEO,IAAIF,IAAI,CAACC,IAAL,KAAc,kBAAd,IAAoC,CAACD,IAAI,CAACG,QAA1C,IAAsDJ,MAAM,CAACC,IAAI,CAACI,QAAN,CAAhE,EAAiF;AACtF;AACA;AACA,YAAIC,GAAG,GAAGL,IAAI,CAACM,MAAf;AACA,eAAOD,GAAG,CAACJ,IAAJ,KAAa,YAAb,IAA6BI,GAAG,CAACH,IAAJ,KAAa,OAAjD;AACD,OALM,MAKA;AACL,eAAO,KAAP;AACD;AACF;AACD;;;;;;;AAOA,aAASK,eAAT,CAAyBP,IAAzB,EAA+B;AAC7B,UAAIA,IAAI,CAACC,IAAL,KAAc,YAAlB,EAAgC;AAC9B,eAAO,CAAC,SAASH,IAAT,CAAcE,IAAI,CAACE,IAAnB,CAAR;AACD,OAFD,MAEO;AACL,eAAO,KAAP;AACD;AACF;;AAED,aAASM,uBAAT,CAAiCR,IAAjC,EAAuC;AACrC,aAAOA,IAAP,EAAa;AACX,YAAIS,YAAY,GAAGC,eAAe,CAACV,IAAD,CAAlC;;AAEA,YAAIS,YAAJ,EAAkB;AAChB,cAAIF,eAAe,CAACE,YAAD,CAAf,IAAiCV,MAAM,CAACU,YAAD,CAA3C,EAA2D;AACzD,mBAAO,IAAP;AACD;AACF;;AAEDT,QAAAA,IAAI,GAAGA,IAAI,CAACW,MAAZ;AACD;;AAED,aAAO,KAAP;AACD;;AAED,QAAIC,WAAW,GAAG;AAChBC,MAAAA,MAAM,EAAE,UAAUC,OAAV,EAAmB;AACzB,YAAIC,0BAA0B,GAAG,EAAjC;AACA,YAAIC,oBAAoB,GAAG,EAA3B;AACA,eAAO;AACL;AACAC,UAAAA,sBAAsB,EAAE,UAAUC,OAAV,EAAmB;AACzC,mBAAOF,oBAAoB,CAACG,IAArB,CAA0BD,OAA1B,CAAP;AACD,WAJI;AAKLE,UAAAA,oBAAoB,EAAE,YAAY;AAChC,mBAAOJ,oBAAoB,CAACK,GAArB,EAAP;AACD,WAPI;AAQL;AACAC,UAAAA,eAAe,EAAE,YAAY;AAC3B,mBAAOP,0BAA0B,CAACI,IAA3B,CAAgC,IAAII,GAAJ,EAAhC,CAAP;AACD,WAXI;AAYL;AACA;AACA;AACA;AACAC,UAAAA,aAAa,EAAE,UAAUC,QAAV,EAAoBC,YAApB,EAAkC;AAC/C,gBAAIC,aAAa,GAAGZ,0BAA0B,CAACM,GAA3B,EAApB;;AAEA,gBAAIM,aAAa,CAACC,IAAd,KAAuB,CAA3B,EAA8B;AAC5B;AACD,aAL8C,CAK7C;;;AAGF,gBAAIC,MAAM,GAAG,IAAIC,GAAJ,EAAb;AACA;;;;;;;;;;;;;;;;;;;;;;AAsBA,qBAASC,mBAAT,CAA6Bb,OAA7B,EAAsC;AACpC,kBAAIc,KAAK,GAAGD,mBAAmB,CAACC,KAAhC;AACA,kBAAIC,KAAK,GAAGD,KAAK,CAACE,GAAN,CAAUhB,OAAO,CAACiB,EAAlB,CAAZ,CAFoC,CAED;AACnC;;AAEA,kBAAIF,KAAK,KAAK,IAAd,EAAoB;AAClB,oBAAIJ,MAAM,CAACO,GAAP,CAAWlB,OAAO,CAACiB,EAAnB,CAAJ,EAA4B;AAC1B,yBAAO,CAAP;AACD,iBAFD,MAEO;AACLN,kBAAAA,MAAM,CAACQ,GAAP,CAAWnB,OAAO,CAACiB,EAAnB;AACA,sBAAIG,yBAAyB,GAAG,IAAhC;AACA,sBAAIC,iBAAiB,GAAG,KAAxB;AACA,sBAAIC,cAAc,GAAGC,SAArB;;AAEA,sBAAI;AACF,yBAAK,IAAIC,SAAS,GAAGxB,OAAO,CAACyB,YAAR,CAAqBC,MAAM,CAACC,QAA5B,GAAhB,EAAyDC,KAA9D,EAAqE,EAAER,yBAAyB,GAAG,CAACQ,KAAK,GAAGJ,SAAS,CAACK,IAAV,EAAT,EAA2BC,IAAzD,CAArE,EAAqIV,yBAAyB,GAAG,IAAjK,EAAuK;AACrK,0BAAIW,WAAW,GAAGH,KAAK,CAACI,KAAxB;AACAnB,sBAAAA,mBAAmB,CAACkB,WAAD,CAAnB;AACD;AACF,mBALD,CAKE,OAAOE,GAAP,EAAY;AACZZ,oBAAAA,iBAAiB,GAAG,IAApB;AACAC,oBAAAA,cAAc,GAAGW,GAAjB;AACD,mBARD,SAQU;AACR,wBAAI;AACF,0BAAI,CAACb,yBAAD,IAA8BI,SAAS,CAACU,MAAV,IAAoB,IAAtD,EAA4D;AAC1DV,wBAAAA,SAAS,CAACU,MAAV;AACD;AACF,qBAJD,SAIU;AACR,0BAAIb,iBAAJ,EAAuB;AACrB,8BAAMC,cAAN;AACD;AACF;AACF;;AAED,yBAAO,CAAP;AACD;AACF,eApCmC,CAoClC;;;AAGF,kBAAIP,KAAK,KAAKQ,SAAd,EAAyB;AACvB,uBAAOR,KAAP;AACD,eAzCmC,CAyClC;;;AAGFD,cAAAA,KAAK,CAACqB,GAAN,CAAUnC,OAAO,CAACiB,EAAlB,EAAsB,IAAtB;;AAEA,kBAAIV,QAAQ,CAAC6B,cAAT,CAAwBC,QAAxB,CAAiCrC,OAAjC,CAAJ,EAA+C;AAC7Ce,gBAAAA,KAAK,GAAG,CAAR;AACD,eAFD,MAEO,IAAIf,OAAO,CAACyB,YAAR,CAAqBa,MAArB,KAAgC,CAApC,EAAuC;AAC5CvB,gBAAAA,KAAK,GAAG,CAAR;AACD,eAFM,MAEA;AACLA,gBAAAA,KAAK,GAAG,CAAR;AACA,oBAAIwB,0BAA0B,GAAG,IAAjC;AACA,oBAAIC,kBAAkB,GAAG,KAAzB;AACA,oBAAIC,eAAe,GAAGlB,SAAtB;;AAEA,oBAAI;AACF,uBAAK,IAAImB,UAAU,GAAG1C,OAAO,CAACyB,YAAR,CAAqBC,MAAM,CAACC,QAA5B,GAAjB,EAA0DgB,MAA/D,EAAuE,EAAEJ,0BAA0B,GAAG,CAACI,MAAM,GAAGD,UAAU,CAACb,IAAX,EAAV,EAA6BC,IAA5D,CAAvE,EAA0IS,0BAA0B,GAAG,IAAvK,EAA6K;AAC3K,wBAAIK,YAAY,GAAGD,MAAM,CAACX,KAA1B;AACAjB,oBAAAA,KAAK,IAAIF,mBAAmB,CAAC+B,YAAD,CAA5B;AACD;AACF,iBALD,CAKE,OAAOX,GAAP,EAAY;AACZO,kBAAAA,kBAAkB,GAAG,IAArB;AACAC,kBAAAA,eAAe,GAAGR,GAAlB;AACD,iBARD,SAQU;AACR,sBAAI;AACF,wBAAI,CAACM,0BAAD,IAA+BG,UAAU,CAACR,MAAX,IAAqB,IAAxD,EAA8D;AAC5DQ,sBAAAA,UAAU,CAACR,MAAX;AACD;AACF,mBAJD,SAIU;AACR,wBAAIM,kBAAJ,EAAwB;AACtB,4BAAMC,eAAN;AACD;AACF;AACF;AACF,eA3EmC,CA2ElC;AACF;;;AAGA,kBAAIzC,OAAO,CAAC6C,SAAR,IAAqB9B,KAAK,KAAK,CAAnC,EAAsC;AACpCD,gBAAAA,KAAK,CAACgC,MAAN,CAAa9C,OAAO,CAACiB,EAArB;AACD,eAFD,MAEO;AACLH,gBAAAA,KAAK,CAACqB,GAAN,CAAUnC,OAAO,CAACiB,EAAlB,EAAsBF,KAAtB;AACD;;AAED,qBAAOA,KAAP;AACD;AACD;;;;;;;;;;;;;;;;;;;;;;;AAuBA,qBAASgC,eAAT,CAAyB/C,OAAzB,EAAkC;AAChC,kBAAIc,KAAK,GAAGiC,eAAe,CAACjC,KAA5B;AACA,kBAAIC,KAAK,GAAGD,KAAK,CAACE,GAAN,CAAUhB,OAAO,CAACiB,EAAlB,CAAZ,CAFgC,CAEG;AACnC;;AAEA,kBAAIF,KAAK,KAAK,IAAd,EAAoB;AAClB,oBAAIJ,MAAM,CAACO,GAAP,CAAWlB,OAAO,CAACiB,EAAnB,CAAJ,EAA4B;AAC1B,yBAAO,CAAP;AACD,iBAFD,MAEO;AACLN,kBAAAA,MAAM,CAACQ,GAAP,CAAWnB,OAAO,CAACiB,EAAnB;AACA,sBAAI+B,0BAA0B,GAAG,IAAjC;AACA,sBAAIC,kBAAkB,GAAG,KAAzB;AACA,sBAAIC,eAAe,GAAG3B,SAAtB;;AAEA,sBAAI;AACF,yBAAK,IAAI4B,UAAU,GAAGnD,OAAO,CAACoD,YAAR,CAAqB1B,MAAM,CAACC,QAA5B,GAAjB,EAA0D0B,MAA/D,EAAuE,EAAEL,0BAA0B,GAAG,CAACK,MAAM,GAAGF,UAAU,CAACtB,IAAX,EAAV,EAA6BC,IAA5D,CAAvE,EAA0IkB,0BAA0B,GAAG,IAAvK,EAA6K;AAC3K,0BAAIM,WAAW,GAAGD,MAAM,CAACrB,KAAzB;AACAe,sBAAAA,eAAe,CAACO,WAAD,CAAf;AACD;AACF,mBALD,CAKE,OAAOrB,GAAP,EAAY;AACZgB,oBAAAA,kBAAkB,GAAG,IAArB;AACAC,oBAAAA,eAAe,GAAGjB,GAAlB;AACD,mBARD,SAQU;AACR,wBAAI;AACF,0BAAI,CAACe,0BAAD,IAA+BG,UAAU,CAACjB,MAAX,IAAqB,IAAxD,EAA8D;AAC5DiB,wBAAAA,UAAU,CAACjB,MAAX;AACD;AACF,qBAJD,SAIU;AACR,0BAAIe,kBAAJ,EAAwB;AACtB,8BAAMC,eAAN;AACD;AACF;AACF;;AAED,yBAAO,CAAP;AACD;AACF,eApC+B,CAoC9B;;;AAGF,kBAAInC,KAAK,KAAKQ,SAAd,EAAyB;AACvB,uBAAOR,KAAP;AACD,eAzC+B,CAyC9B;;;AAGFD,cAAAA,KAAK,CAACqB,GAAN,CAAUnC,OAAO,CAACiB,EAAlB,EAAsB,IAAtB;;AAEA,kBAAIV,QAAQ,CAAC6B,cAAT,CAAwBC,QAAxB,CAAiCrC,OAAjC,CAAJ,EAA+C;AAC7Ce,gBAAAA,KAAK,GAAG,CAAR;AACD,eAFD,MAEO,IAAIf,OAAO,CAACoD,YAAR,CAAqBd,MAArB,KAAgC,CAApC,EAAuC;AAC5CvB,gBAAAA,KAAK,GAAG,CAAR;AACD,eAFM,MAEA;AACLA,gBAAAA,KAAK,GAAG,CAAR;AACA,oBAAIwC,0BAA0B,GAAG,IAAjC;AACA,oBAAIC,kBAAkB,GAAG,KAAzB;AACA,oBAAIC,eAAe,GAAGlC,SAAtB;;AAEA,oBAAI;AACF,uBAAK,IAAImC,UAAU,GAAG1D,OAAO,CAACoD,YAAR,CAAqB1B,MAAM,CAACC,QAA5B,GAAjB,EAA0DgC,MAA/D,EAAuE,EAAEJ,0BAA0B,GAAG,CAACI,MAAM,GAAGD,UAAU,CAAC7B,IAAX,EAAV,EAA6BC,IAA5D,CAAvE,EAA0IyB,0BAA0B,GAAG,IAAvK,EAA6K;AAC3K,wBAAIK,YAAY,GAAGD,MAAM,CAAC3B,KAA1B;AACAjB,oBAAAA,KAAK,IAAIgC,eAAe,CAACa,YAAD,CAAxB;AACD;AACF,iBALD,CAKE,OAAO3B,GAAP,EAAY;AACZuB,kBAAAA,kBAAkB,GAAG,IAArB;AACAC,kBAAAA,eAAe,GAAGxB,GAAlB;AACD,iBARD,SAQU;AACR,sBAAI;AACF,wBAAI,CAACsB,0BAAD,IAA+BG,UAAU,CAACxB,MAAX,IAAqB,IAAxD,EAA8D;AAC5DwB,sBAAAA,UAAU,CAACxB,MAAX;AACD;AACF,mBAJD,SAIU;AACR,wBAAIsB,kBAAJ,EAAwB;AACtB,4BAAMC,eAAN;AACD;AACF;AACF;AACF;;AAED3C,cAAAA,KAAK,CAACqB,GAAN,CAAUnC,OAAO,CAACiB,EAAlB,EAAsBF,KAAtB;AACA,qBAAOA,KAAP;AACD;AACD;;;;;;;;;;;;;;;;;;;;;;;AAuBA,qBAAS8C,yBAAT,CAAmC7D,OAAnC,EAA4C;AAC1C,kBAAIc,KAAK,GAAG+C,yBAAyB,CAAC/C,KAAtC;AACA,kBAAIwB,MAAM,GAAGxB,KAAK,CAACE,GAAN,CAAUhB,OAAO,CAACiB,EAAlB,CAAb,CAF0C,CAEN;AACpC;;AAEA,kBAAIqB,MAAM,KAAK,IAAf,EAAqB;AACnB,uBAAOwB,QAAP;AACD,eAPyC,CAOxC;;;AAGF,kBAAIxB,MAAM,KAAKf,SAAf,EAA0B;AACxB,uBAAOe,MAAP;AACD,eAZyC,CAYxC;;;AAGFxB,cAAAA,KAAK,CAACqB,GAAN,CAAUnC,OAAO,CAACiB,EAAlB,EAAsB,IAAtB;;AAEA,kBAAIjB,OAAO,CAACyB,YAAR,CAAqBa,MAArB,KAAgC,CAApC,EAAuC;AACrCA,gBAAAA,MAAM,GAAG,CAAT;AACD,eAFD,MAEO;AACLA,gBAAAA,MAAM,GAAGwB,QAAT;AACA,oBAAIC,0BAA0B,GAAG,IAAjC;AACA,oBAAIC,kBAAkB,GAAG,KAAzB;AACA,oBAAIC,eAAe,GAAG1C,SAAtB;;AAEA,oBAAI;AACF,uBAAK,IAAI2C,UAAU,GAAGlE,OAAO,CAACyB,YAAR,CAAqBC,MAAM,CAACC,QAA5B,GAAjB,EAA0DwC,MAA/D,EAAuE,EAAEJ,0BAA0B,GAAG,CAACI,MAAM,GAAGD,UAAU,CAACrC,IAAX,EAAV,EAA6BC,IAA5D,CAAvE,EAA0IiC,0BAA0B,GAAG,IAAvK,EAA6K;AAC3K,wBAAIhC,WAAW,GAAGoC,MAAM,CAACnC,KAAzB;AACA,wBAAIoC,UAAU,GAAGP,yBAAyB,CAAC9B,WAAD,CAA1C;;AAEA,wBAAIqC,UAAU,GAAG9B,MAAjB,EAAyB;AACvBA,sBAAAA,MAAM,GAAG8B,UAAT;AACD;AACF;AACF,iBATD,CASE,OAAOnC,GAAP,EAAY;AACZ+B,kBAAAA,kBAAkB,GAAG,IAArB;AACAC,kBAAAA,eAAe,GAAGhC,GAAlB;AACD,iBAZD,SAYU;AACR,sBAAI;AACF,wBAAI,CAAC8B,0BAAD,IAA+BG,UAAU,CAAChC,MAAX,IAAqB,IAAxD,EAA8D;AAC5DgC,sBAAAA,UAAU,CAAChC,MAAX;AACD;AACF,mBAJD,SAIU;AACR,wBAAI8B,kBAAJ,EAAwB;AACtB,4BAAMC,eAAN;AACD;AACF;AACF;;AAED3B,gBAAAA,MAAM,IAAI,CAAV;AACD;;AAEDxB,cAAAA,KAAK,CAACqB,GAAN,CAAUnC,OAAO,CAACiB,EAAlB,EAAsBqB,MAAtB;AACA,qBAAOA,MAAP;AACD;;AAEDzB,YAAAA,mBAAmB,CAACC,KAApB,GAA4B,IAAIT,GAAJ,EAA5B;AACA0C,YAAAA,eAAe,CAACjC,KAAhB,GAAwB,IAAIT,GAAJ,EAAxB;AACAwD,YAAAA,yBAAyB,CAAC/C,KAA1B,GAAkC,IAAIT,GAAJ,EAAlC,CA9S+C,CA8SF;AAC7C;;AAEA,gBAAIgE,sBAAsB,GAAGtB,eAAe,CAACxC,QAAQ,CAAC+D,cAAV,CAA5C,CAjT+C,CAiTwB;AACvE;AACA;AACA;AACA;;AAEA,gBAAIC,oBAAoB,GAAG/E,eAAe,CAACgB,YAAD,CAA1C,CAvT+C,CAuTW;AAC1D;;AAEA,gBAAIgE,gCAAgC,GAAGlF,uBAAuB,CAACkB,YAAD,CAA9D;AACA,gBAAIiE,+BAA+B,GAAGF,oBAAoB,GAAGlF,eAAe,CAACkF,oBAAD,CAAf,IAAyC1F,MAAM,CAAC0F,oBAAD,CAAlD,GAA2E,KAArI,CA3T+C,CA2T6F;AAC5I;AACA;;AAEA,gBAAIG,uBAAuB,GAAGZ,QAA9B;AACA,gBAAIa,0BAA0B,GAAG,IAAjC;AACA,gBAAIC,kBAAkB,GAAG,KAAzB;AACA,gBAAIC,eAAe,GAAGtD,SAAtB;;AAEA,gBAAI;AACF,mBAAK,IAAIuD,UAAU,GAAGvE,QAAQ,CAACwE,aAAT,CAAuBrD,MAAM,CAACC,QAA9B,GAAjB,EAA4DqD,MAAjE,EAAyE,EAAEL,0BAA0B,GAAG,CAACK,MAAM,GAAGF,UAAU,CAACjD,IAAX,EAAV,EAA6BC,IAA5D,CAAzE,EAA4I6C,0BAA0B,GAAG,IAAzK,EAA+K;AAC7K,oBAAIM,YAAY,GAAGD,MAAM,CAAChD,KAA1B;;AAEA,oBAAI,CAACiD,YAAY,CAACpC,SAAlB,EAA6B;AAC3B;AACD;;AAED,oBAAIP,MAAM,GAAGuB,yBAAyB,CAACoB,YAAD,CAAtC;;AAEA,oBAAI3C,MAAM,GAAGoC,uBAAb,EAAsC;AACpCA,kBAAAA,uBAAuB,GAAGpC,MAA1B;AACD;AACF,eAbC,CAaA;AACF;;AAED,aAhBD,CAgBE,OAAOL,GAAP,EAAY;AACZ2C,cAAAA,kBAAkB,GAAG,IAArB;AACAC,cAAAA,eAAe,GAAG5C,GAAlB;AACD,aAnBD,SAmBU;AACR,kBAAI;AACF,oBAAI,CAAC0C,0BAAD,IAA+BG,UAAU,CAAC5C,MAAX,IAAqB,IAAxD,EAA8D;AAC5D4C,kBAAAA,UAAU,CAAC5C,MAAX;AACD;AACF,eAJD,SAIU;AACR,oBAAI0C,kBAAJ,EAAwB;AACtB,wBAAMC,eAAN;AACD;AACF;AACF;;AAED,gBAAIK,0BAA0B,GAAG,IAAjC;AACA,gBAAIC,kBAAkB,GAAG,KAAzB;AACA,gBAAIC,eAAe,GAAG7D,SAAtB;;AAEA,gBAAI;AACF,mBAAK,IAAI8D,UAAU,GAAG5E,aAAa,CAACiB,MAAM,CAACC,QAAR,CAAb,EAAjB,EAAmD2D,MAAxD,EAAgE,EAAEJ,0BAA0B,GAAG,CAACI,MAAM,GAAGD,UAAU,CAACxD,IAAX,EAAV,EAA6BC,IAA5D,CAAhE,EAAmIoD,0BAA0B,GAAG,IAAhK,EAAsK;AACpK,oBAAIK,YAAY,GAAGD,MAAM,CAACtD,KAA1B;AAAA,oBACIhC,OAAO,GAAGuF,YAAY,CAAC,CAAD,CAD1B;AAAA,oBAEIC,UAAU,GAAGD,YAAY,CAAC,CAAD,CAF7B,CADoK,CAKpK;AACA;AACA;;AACA,oBAAI,CAACvF,OAAO,CAAC6C,SAAb,EAAwB;AACtB;AACD,iBAVmK,CAUlK;AACF;AACA;AACA;AACA;;;AAGA,oBAAI4C,sBAAsB,GAAGzF,OAAO,CAACoD,YAAR,CAAqBd,MAArB,KAAgC,CAAhC,GAAoCoC,uBAAuB,IAAIb,yBAAyB,CAAC7D,OAAD,CAAxF,GAAoG0E,uBAAuB,GAAGb,yBAAyB,CAAC7D,OAAD,CAApL,CAjBoK,CAiB2B;AAC/L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAI0F,mBAAmB,GAAG7E,mBAAmB,CAACb,OAAD,CAAnB,GAA+B+C,eAAe,CAAC/C,OAAD,CAAxE,CArDoK,CAqDjF;;AAEnF,oBAAI2F,MAAM,GAAGhF,MAAM,CAACO,GAAP,CAAWlB,OAAO,CAACiB,EAAnB,CAAb;AACA,oBAAI2E,0BAA0B,GAAG,IAAjC;AACA,oBAAIC,kBAAkB,GAAG,KAAzB;AACA,oBAAIC,eAAe,GAAGvE,SAAtB;;AAEA,oBAAI;AACF,uBAAK,IAAIwE,UAAU,GAAGP,UAAU,CAAC9D,MAAM,CAACC,QAAR,CAAV,EAAjB,EAAgDqE,MAArD,EAA6D,EAAEJ,0BAA0B,GAAG,CAACI,MAAM,GAAGD,UAAU,CAAClE,IAAX,EAAV,EAA6BC,IAA5D,CAA7D,EAAgI8D,0BAA0B,GAAG,IAA7J,EAAmK;AACjK,wBAAIK,IAAI,GAAGD,MAAM,CAAChE,KAAlB,CADiK,CAGjK;;AACA,wBAAI2D,MAAJ,EAAY;AACV/F,sBAAAA,OAAO,CAACsG,MAAR,CAAe;AACbpH,wBAAAA,IAAI,EAAEmH,IADO;AAEbE,wBAAAA,OAAO,EAAE,kBAAkBvG,OAAO,CAACwG,SAAR,CAAkBH,IAAlB,CAAlB,GAA4C,qBAA5C,GAAoE,2DAApE,GAAkI,wDAAlI,GAA6L;AAFzL,uBAAf;AAID,qBATgK,CAS/J;AACF;AACA;AACA;AACA;;;AAGA,wBAAIxB,+BAAJ,EAAqC;AACnC;AACA;AACA;AACA;AACA,0BAAI,CAACkB,MAAD,IAAWD,mBAAmB,KAAKrB,sBAAvC,EAA+D;AAC7D,4BAAI8B,OAAO,GAAG,kBAAkBvG,OAAO,CAACwG,SAAR,CAAkBH,IAAlB,CAAlB,GAA4C,eAA5C,GAA8D,yDAA9D,GAA0H,uCAA1H,IAAqKR,sBAAsB,GAAG,qDAAqD,gBAAxD,GAA2E,EAAtQ,CAAd;AACA7F,wBAAAA,OAAO,CAACsG,MAAR,CAAe;AACbpH,0BAAAA,IAAI,EAAEmH,IADO;AAEbE,0BAAAA,OAAO,EAAEA;AAFI,yBAAf;AAID;AACF,qBAZD,MAYO,IAAI3F,YAAY,CAACf,MAAb,KAAwBe,YAAY,CAACf,MAAb,CAAoBV,IAApB,KAA6B,kBAA7B,IAAmDyB,YAAY,CAACf,MAAb,CAAoBV,IAApB,KAA6B,eAAxG,KAA4HyB,YAAY,CAACf,MAAb,CAAoBuC,KAApB,KAA8BxB,YAA9J,EAA4K,CAAC;AAClL;AACA;AACA;AACA;AACD,qBALM,MAKA,IAAI+D,oBAAJ,EAA0B;AAC/B;AACA,0BAAI8B,QAAQ,GAAG,kBAAkBzG,OAAO,CAACwG,SAAR,CAAkBH,IAAlB,CAAlB,GAA4C,kBAA5C,IAAkE,gBAAgBrG,OAAO,CAACwG,SAAR,CAAkB7B,oBAAlB,CAAhB,GAA0D,KAA5H,IAAqI,0DAArI,GAAkM,sBAAjN;;AAEA3E,sBAAAA,OAAO,CAACsG,MAAR,CAAe;AACbpH,wBAAAA,IAAI,EAAEmH,IADO;AAEbE,wBAAAA,OAAO,EAAEE;AAFI,uBAAf;AAID,qBARM,MAQA,IAAI7F,YAAY,CAACzB,IAAb,KAAsB,SAA1B,EAAqC;AAC1C;AACA,0BAAIuH,SAAS,GAAG,kBAAkB1G,OAAO,CAACwG,SAAR,CAAkBH,IAAlB,CAAlB,GAA4C,sBAA5C,GAAqE,oDAArE,GAA4H,2DAA5I;;AAEArG,sBAAAA,OAAO,CAACsG,MAAR,CAAe;AACbpH,wBAAAA,IAAI,EAAEmH,IADO;AAEbE,wBAAAA,OAAO,EAAEG;AAFI,uBAAf;AAID,qBARM,MAQA;AACL;AACA;AACA;AACA;AACA;AACA,0BAAI9B,gCAAJ,EAAsC;AACpC,4BAAI+B,SAAS,GAAG,kBAAkB3G,OAAO,CAACwG,SAAR,CAAkBH,IAAlB,CAAlB,GAA4C,sBAA5C,GAAqE,qDAArE,GAA6H,2DAA7I;;AAEArG,wBAAAA,OAAO,CAACsG,MAAR,CAAe;AACbpH,0BAAAA,IAAI,EAAEmH,IADO;AAEbE,0BAAAA,OAAO,EAAEI;AAFI,yBAAf;AAID;AACF;AACF;AACF,iBAlED,CAkEE,OAAOtE,GAAP,EAAY;AACZ4D,kBAAAA,kBAAkB,GAAG,IAArB;AACAC,kBAAAA,eAAe,GAAG7D,GAAlB;AACD,iBArED,SAqEU;AACR,sBAAI;AACF,wBAAI,CAAC2D,0BAAD,IAA+BG,UAAU,CAAC7D,MAAX,IAAqB,IAAxD,EAA8D;AAC5D6D,sBAAAA,UAAU,CAAC7D,MAAX;AACD;AACF,mBAJD,SAIU;AACR,wBAAI2D,kBAAJ,EAAwB;AACtB,4BAAMC,eAAN;AACD;AACF;AACF;AACF;AACF,aA9ID,CA8IE,OAAO7D,GAAP,EAAY;AACZkD,cAAAA,kBAAkB,GAAG,IAArB;AACAC,cAAAA,eAAe,GAAGnD,GAAlB;AACD,aAjJD,SAiJU;AACR,kBAAI;AACF,oBAAI,CAACiD,0BAAD,IAA+BG,UAAU,CAACnD,MAAX,IAAqB,IAAxD,EAA8D;AAC5DmD,kBAAAA,UAAU,CAACnD,MAAX;AACD;AACF,eAJD,SAIU;AACR,oBAAIiD,kBAAJ,EAAwB;AACtB,wBAAMC,eAAN;AACD;AACF;AACF;AACF,WAnhBI;AAohBL;AACA;AACA;AACA;AACAoB,UAAAA,cAAc,EAAE,UAAU1H,IAAV,EAAgB;AAC9B,gBAAID,MAAM,CAACC,IAAI,CAAC2H,MAAN,CAAV,EAAyB;AACvB;AACA;AACA,kBAAIhG,aAAa,GAAGiG,IAAI,CAAC7G,0BAAD,CAAxB;AACA,kBAAI8G,eAAe,GAAGD,IAAI,CAAC5G,oBAAD,CAA1B;AACA,kBAAI0F,UAAU,GAAG/E,aAAa,CAACO,GAAd,CAAkB2F,eAAlB,CAAjB;;AAEA,kBAAI,CAACnB,UAAL,EAAiB;AACfA,gBAAAA,UAAU,GAAG,EAAb;AACA/E,gBAAAA,aAAa,CAAC0B,GAAd,CAAkBwE,eAAlB,EAAmCnB,UAAnC;AACD;;AAEDA,cAAAA,UAAU,CAACvF,IAAX,CAAgBnB,IAAI,CAAC2H,MAArB;AACD;AACF;AAviBI,SAAP;AAyiBD;AA7iBe,KAAlB;AA+iBA;;;;;;;;AAQA,aAASjH,eAAT,CAAyBV,IAAzB,EAA+B;AAC7B,UAAIA,IAAI,CAACC,IAAL,KAAc,qBAAd,IAAuCD,IAAI,CAACC,IAAL,KAAc,oBAAd,IAAsCD,IAAI,CAACmC,EAAtF,EAA0F;AACxF;AACA;AACA;AACA;AACA;AACA,eAAOnC,IAAI,CAACmC,EAAZ;AACD,OAPD,MAOO,IAAInC,IAAI,CAACC,IAAL,KAAc,oBAAd,IAAsCD,IAAI,CAACC,IAAL,KAAc,yBAAxD,EAAmF;AACxF,YAAID,IAAI,CAACW,MAAL,CAAYV,IAAZ,KAAqB,oBAArB,IAA6CD,IAAI,CAACW,MAAL,CAAYmH,IAAZ,KAAqB9H,IAAtE,EAA4E;AAC1E;AACA,iBAAOA,IAAI,CAACW,MAAL,CAAYwB,EAAnB;AACD,SAHD,MAGO,IAAInC,IAAI,CAACW,MAAL,CAAYV,IAAZ,KAAqB,sBAArB,IAA+CD,IAAI,CAACW,MAAL,CAAYoH,KAAZ,KAAsB/H,IAArE,IAA6EA,IAAI,CAACW,MAAL,CAAYqH,QAAZ,KAAyB,GAA1G,EAA+G;AACpH;AACA,iBAAOhI,IAAI,CAACW,MAAL,CAAYsH,IAAnB;AACD,SAHM,MAGA,IAAIjI,IAAI,CAACW,MAAL,CAAYV,IAAZ,KAAqB,UAArB,IAAmCD,IAAI,CAACW,MAAL,CAAYuC,KAAZ,KAAsBlD,IAAzD,IAAiE,CAACA,IAAI,CAACW,MAAL,CAAYR,QAAlF,EAA4F;AACjG;AACA;AACA,iBAAOH,IAAI,CAACW,MAAL,CAAYuH,GAAnB,CAHiG,CAGzE;AACxB;AACA;AACA;AACA;AACA;AACD,SATM,MASA,IAAIlI,IAAI,CAACW,MAAL,CAAYV,IAAZ,KAAqB,mBAArB,IAA4CD,IAAI,CAACW,MAAL,CAAYoH,KAAZ,KAAsB/H,IAAlE,IAA0E,CAACA,IAAI,CAACW,MAAL,CAAYR,QAA3F,EAAqG;AAC1G;AACA;AACA;AACA;AACA;AACA,iBAAOH,IAAI,CAACW,MAAL,CAAYsH,IAAnB;AACD,SAPM,MAOA;AACL,iBAAOxF,SAAP;AACD;AACF,OA1BM,MA0BA;AACL,eAAOA,SAAP;AACD;AACF;AACD;;;;;AAKA,aAASmF,IAAT,CAAcO,KAAd,EAAqB;AACnB,aAAOA,KAAK,CAACA,KAAK,CAAC3E,MAAN,GAAe,CAAhB,CAAZ;AACD;AAED;;;AAGA,QAAI4E,cAAc,GAAG;AACnBC,MAAAA,IAAI,EAAE;AACJC,QAAAA,OAAO,EAAE,MADL;AAEJC,QAAAA,MAAM,EAAE,CAAC;AACPtI,UAAAA,IAAI,EAAE,QADC;AAEPuI,UAAAA,oBAAoB,EAAE,KAFf;AAGPC,UAAAA,UAAU,EAAE;AACVC,YAAAA,eAAe,EAAE;AACfzI,cAAAA,IAAI,EAAE;AADS;AADP;AAHL,SAAD;AAFJ,OADa;AAanBY,MAAAA,MAAM,EAAE,UAAUC,OAAV,EAAmB;AACzB;AACA,YAAI4H,eAAe,GAAG5H,OAAO,CAAC6H,OAAR,IAAmB7H,OAAO,CAAC6H,OAAR,CAAgB,CAAhB,CAAnB,IAAyC7H,OAAO,CAAC6H,OAAR,CAAgB,CAAhB,EAAmBD,eAA5D,GAA8E,IAAIE,MAAJ,CAAW9H,OAAO,CAAC6H,OAAR,CAAgB,CAAhB,EAAmBD,eAA9B,CAA9E,GAA+HjG,SAArJ;AACA,YAAIkG,OAAO,GAAG;AACZD,UAAAA,eAAe,EAAEA;AADL,SAAd,CAHyB,CAKtB;;AAEH,YAAIG,iBAAiB,GAAG,IAAIC,OAAJ,EAAxB;AACA,YAAIC,cAAc,GAAG,IAAIC,OAAJ,EAArB;AACA,YAAIC,qBAAqB,GAAG,IAAIH,OAAJ,EAA5B;AACA,YAAII,iCAAiC,GAAG,IAAIJ,OAAJ,EAAxC;;AAEA,iBAASK,kBAAT,CAA4BC,EAA5B,EAAgCC,GAAhC,EAAqC;AACnC,iBAAO,UAAUC,GAAV,EAAe;AACpB,gBAAID,GAAG,CAACjH,GAAJ,CAAQkH,GAAR,CAAJ,EAAkB;AAChB;AACA;AACA,qBAAOD,GAAG,CAACnH,GAAJ,CAAQoH,GAAR,CAAP;AACD;;AAED,gBAAIC,MAAM,GAAGH,EAAE,CAACE,GAAD,CAAf;AACAD,YAAAA,GAAG,CAAChG,GAAJ,CAAQiG,GAAR,EAAaC,MAAb;AACA,mBAAOA,MAAP;AACD,WAVD;AAWD;;AAED,eAAO;AACLC,UAAAA,kBAAkB,EAAEC,uBADf;AAELC,UAAAA,uBAAuB,EAAED;AAFpB,SAAP;AAIA;;;;AAIA,iBAASA,uBAAT,CAAiCzJ,IAAjC,EAAuC;AACrC;AACA,cAAIA,IAAI,CAACC,IAAL,KAAc,oBAAd,IAAsCD,IAAI,CAACC,IAAL,KAAc,yBAApD,IAAiFD,IAAI,CAACW,MAAL,CAAYV,IAAZ,KAAqB,gBAA1G,EAA4H;AAC1H;AACD;;AAED,cAAI0J,aAAa,GAAGC,4BAA4B,CAAC5J,IAAI,CAACW,MAAL,CAAYgH,MAAb,EAAqBgB,OAArB,CAAhD;;AAEA,cAAI3I,IAAI,CAACW,MAAL,CAAYkJ,SAAZ,CAAsBF,aAAtB,MAAyC3J,IAA7C,EAAmD;AACjD;AACD,WAVoC,CAUnC;;;AAGF,cAAI8J,YAAY,GAAG9J,IAAI,CAACW,MAAL,CAAYgH,MAA/B;AACA,cAAIoC,gBAAgB,GAAGC,4BAA4B,CAACF,YAAD,CAA5B,CAA2C5J,IAAlE;AACA,cAAI+J,QAAQ,GAAGF,gBAAgB,CAACG,QAAjB,CAA0B,QAA1B,CAAf,CAfqC,CAee;AACpD;AACA;;AAEA,cAAIC,SAAS,GAAGR,aAAa,GAAG,CAAhC;AACA,cAAIS,wBAAwB,GAAGpK,IAAI,CAACW,MAAL,CAAYkJ,SAAZ,CAAsBM,SAAtB,CAA/B;;AAEA,cAAI,CAACC,wBAAD,IAA6B,CAACH,QAAlC,EAA4C;AAC1C;AACA,gBAAIF,gBAAgB,KAAK,SAArB,IAAkCA,gBAAgB,KAAK,aAA3D,EAA0E;AACxE;AACAjJ,cAAAA,OAAO,CAACsG,MAAR,CAAe;AACbpH,gBAAAA,IAAI,EAAEA,IAAI,CAACW,MAAL,CAAYgH,MADL;AAEbN,gBAAAA,OAAO,EAAE,gBAAgB0C,gBAAhB,GAAmC,iCAAnC,GAAuE,wDAAvE,GAAkI;AAF9H,eAAf;AAID;;AAED;AACD;;AAED,cAAIE,QAAQ,IAAIjK,IAAI,CAACqK,KAArB,EAA4B;AAC1BvJ,YAAAA,OAAO,CAACsG,MAAR,CAAe;AACbpH,cAAAA,IAAI,EAAEA,IADO;AAEbqH,cAAAA,OAAO,EAAE,kEAAkE,oCAAlE,GAAyG,qBAAzG,GAAiI,kCAAjI,GAAsK,6BAAtK,GAAsM,qDAAtM,GAA8P,cAA9P,GAA+Q,OAA/Q,GAAyR,kBAAzR,GAA8S,kEAA9S,GAAmX;AAF/W,aAAf;AAID,WAxCoC,CAwCnC;;;AAGF,cAAIiD,KAAK,GAAGxJ,OAAO,CAACyJ,QAAR,EAAZ,CA3CqC,CA2CL;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAIC,UAAU,GAAG,IAAI1I,GAAJ,EAAjB;AACA,cAAI2I,cAAc,GAAG,IAArB;AACA;AACE,gBAAIC,YAAY,GAAGJ,KAAK,CAACK,KAAzB;;AAEA,mBAAOD,YAAP,EAAqB;AACnBF,cAAAA,UAAU,CAACnI,GAAX,CAAeqI,YAAf;;AAEA,kBAAIA,YAAY,CAACzK,IAAb,KAAsB,UAA1B,EAAsC;AACpC;AACD;;AAEDyK,cAAAA,YAAY,GAAGA,YAAY,CAACC,KAA5B;AACD,aAXH,CAWI;AACF;AACA;;;AAGA,gBAAI,CAACD,YAAL,EAAmB;AACjB;AACD;;AAEDD,YAAAA,cAAc,GAAGC,YAAjB;AACD,WA3EoC,CA2EnC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAASE,sBAAT,CAAgCC,QAAhC,EAA0C;AACxC,gBAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,QAAQ,CAACG,IAAvB,CAAL,EAAmC;AACjC,qBAAO,KAAP;AACD;;AAED,gBAAIC,GAAG,GAAGJ,QAAQ,CAACG,IAAT,CAAc,CAAd,CAAV;;AAEA,gBAAIC,GAAG,IAAI,IAAX,EAAiB;AACf,qBAAO,KAAP;AACD,aATuC,CAStC;;;AAGF,gBAAIA,GAAG,CAACjL,IAAJ,CAASC,IAAT,KAAkB,oBAAtB,EAA4C;AAC1C,qBAAO,KAAP;AACD;;AAED,gBAAI6H,IAAI,GAAGmD,GAAG,CAACjL,IAAJ,CAAS8H,IAApB;;AAEA,gBAAIA,IAAI,IAAI,IAAZ,EAAkB;AAChB,qBAAO,KAAP;AACD,aApBuC,CAoBtC;AACF;;;AAGA,gBAAIoD,WAAW,GAAGD,GAAG,CAACjL,IAAJ,CAASW,MAA3B;;AAEA,gBAAIuK,WAAW,IAAI,IAAnB,EAAyB;AACvB;AACA;AACA;AACAC,cAAAA,2BAA2B,CAACV,cAAc,CAACW,KAAhB,EAAuBH,GAAG,CAACjL,IAAJ,CAASmC,EAAhC,CAA3B;AACA+I,cAAAA,WAAW,GAAGD,GAAG,CAACjL,IAAJ,CAASW,MAAvB;;AAEA,kBAAIuK,WAAW,IAAI,IAAnB,EAAyB;AACvB,uBAAO,KAAP;AACD;AACF;;AAED,gBAAIA,WAAW,CAACG,IAAZ,KAAqB,OAArB,IAAgCvD,IAAI,CAAC7H,IAAL,KAAc,SAA9C,KAA4D,OAAO6H,IAAI,CAAC5E,KAAZ,KAAsB,QAAtB,IAAkC,OAAO4E,IAAI,CAAC5E,KAAZ,KAAsB,QAAxD,IAAoE4E,IAAI,CAAC5E,KAAL,KAAe,IAA/I,CAAJ,EAA0J;AACxJ;AACA,qBAAO,IAAP;AACD,aAzCuC,CAyCtC;AACF;;;AAGA,gBAAI4E,IAAI,CAAC7H,IAAL,KAAc,gBAAlB,EAAoC;AAClC,qBAAO,KAAP;AACD;;AAED,gBAAI0H,MAAM,GAAGG,IAAI,CAACH,MAAlB,CAjDwC,CAiDd;;AAE1B,gBAAIA,MAAM,CAAC1H,IAAP,KAAgB,kBAAhB,IAAsC0H,MAAM,CAACrH,MAAP,CAAcJ,IAAd,KAAuB,OAA7D,IAAwEyH,MAAM,CAACvH,QAAP,IAAmB,IAA3F,IAAmG,CAACuH,MAAM,CAACxH,QAA/G,EAAyH;AACvHwH,cAAAA,MAAM,GAAGA,MAAM,CAACvH,QAAhB;AACD;;AAED,gBAAIuH,MAAM,CAAC1H,IAAP,KAAgB,YAApB,EAAkC;AAChC,qBAAO,KAAP;AACD;;AAED,gBAAIkC,EAAE,GAAG8I,GAAG,CAACjL,IAAJ,CAASmC,EAAlB;AACA,gBAAImJ,OAAO,GAAG3D,MAAd;AAAA,gBACIzH,IAAI,GAAGoL,OAAO,CAACpL,IADnB;;AAGA,gBAAIA,IAAI,KAAK,QAAT,IAAqBiC,EAAE,CAAClC,IAAH,KAAY,YAArC,EAAmD;AACjD;AACA,qBAAO,IAAP;AACD,aAHD,MAGO,IAAIC,IAAI,KAAK,UAAT,IAAuBA,IAAI,KAAK,YAApC,EAAkD;AACvD;AACA,kBAAIiC,EAAE,CAAClC,IAAH,KAAY,cAAZ,IAA8BkC,EAAE,CAACoJ,QAAH,CAAY/H,MAAZ,KAAuB,CAArD,IAA0DsH,KAAK,CAACC,OAAN,CAAcF,QAAQ,CAACW,WAAvB,CAA9D,EAAmG;AACjG;AACA,oBAAIrJ,EAAE,CAACoJ,QAAH,CAAY,CAAZ,MAAmBV,QAAQ,CAACW,WAAT,CAAqB,CAArB,CAAvB,EAAgD;AAC9C,sBAAItL,IAAI,KAAK,UAAb,EAAyB;AACvB,wBAAIuL,UAAU,GAAGZ,QAAQ,CAACY,UAA1B;;AAEA,yBAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,UAAU,CAACjI,MAA/B,EAAuCkI,CAAC,EAAxC,EAA4C;AAC1C7C,sBAAAA,iBAAiB,CAACxF,GAAlB,CAAsBoI,UAAU,CAACC,CAAD,CAAV,CAAcC,UAApC,EAAgDxJ,EAAE,CAACoJ,QAAH,CAAY,CAAZ,CAAhD;AACD;AACF,mBAP6C,CAO5C;;;AAGF,yBAAO,IAAP;AACD,iBAXD,MAWO,IAAIpJ,EAAE,CAACoJ,QAAH,CAAY,CAAZ,MAAmBV,QAAQ,CAACW,WAAT,CAAqB,CAArB,CAAvB,EAAgD;AACrD,sBAAItL,IAAI,KAAK,UAAb,EAAyB;AACvB,wBAAI0L,WAAW,GAAGf,QAAQ,CAACY,UAA3B;;AAEA,yBAAK,IAAII,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGD,WAAW,CAACpI,MAAlC,EAA0CqI,EAAE,EAA5C,EAAgD;AAC9C9C,sBAAAA,cAAc,CAAC1G,GAAf,CAAmBuJ,WAAW,CAACC,EAAD,CAAX,CAAgBF,UAAnC;AACD;AACF,mBAPoD,CAOnD;;;AAGF,yBAAO,KAAP;AACD;AACF;AACF,aA9FuC,CA8FtC;;;AAGF,mBAAO,KAAP;AACD,WAxLoC,CAwLnC;;;AAGF,mBAASG,+BAAT,CAAyCjB,QAAzC,EAAmD;AACjD,gBAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,QAAQ,CAACG,IAAvB,CAAL,EAAmC;AACjC,qBAAO,KAAP;AACD;;AAED,gBAAIC,GAAG,GAAGJ,QAAQ,CAACG,IAAT,CAAc,CAAd,CAAV;;AAEA,gBAAIC,GAAG,IAAI,IAAX,EAAiB;AACf,qBAAO,KAAP;AACD;;AAED,gBAAIA,GAAG,CAACjL,IAAJ,IAAY,IAAZ,IAAoBiL,GAAG,CAACjL,IAAJ,CAASmC,EAAT,IAAe,IAAvC,EAA6C;AAC3C,qBAAO,KAAP;AACD,aAbgD,CAa/C;AACF;;;AAGA,gBAAI4J,MAAM,GAAGd,GAAG,CAACjL,IAAjB;AACA,gBAAIgM,WAAW,GAAGvB,cAAc,CAACuB,WAAjC;AACA,gBAAIC,OAAO,GAAG,IAAd;AACA,gBAAIP,CAAJ;;AAEA,iBAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGM,WAAW,CAACxI,MAA5B,EAAoCkI,CAAC,EAArC,EAAyC;AACvC,kBAAIQ,UAAU,GAAGF,WAAW,CAACN,CAAD,CAA5B;AACA,kBAAIS,eAAe,GAAGD,UAAU,CAACd,KAAjC;;AAEA,mBAAK;AACLW,cAAAA,MAAM,CAAC9L,IAAP,KAAgB,qBAAhB,IAAyCkM,eAAe,KAAKJ,MAA7D,IAAuE;AACvE;AACAA,cAAAA,MAAM,CAAC9L,IAAP,KAAgB,oBAAhB,IAAwCkM,eAAe,CAACxL,MAAhB,KAA2BoL,MAHnE,EAG2E;AACzE;AACAE,gBAAAA,OAAO,GAAGC,UAAV;AACA;AACD;AACF;;AAED,gBAAID,OAAO,IAAI,IAAf,EAAqB;AACnB,qBAAO,KAAP;AACD,aAtCgD,CAsC/C;AACF;;;AAGA,iBAAKP,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGO,OAAO,CAACG,OAAR,CAAgB5I,MAAhC,EAAwCkI,CAAC,EAAzC,EAA6C;AAC3C,kBAAIW,GAAG,GAAGJ,OAAO,CAACG,OAAR,CAAgBV,CAAhB,CAAV;;AAEA,kBAAIW,GAAG,CAACxB,QAAJ,IAAgB,IAApB,EAA0B;AACxB;AACD;;AAED,kBAAIL,UAAU,CAACpI,GAAX,CAAeiK,GAAG,CAACxB,QAAJ,CAAaP,KAA5B,KAAsC;AAC1C;AACA,eAACgC,8BAA8B,CAACD,GAAG,CAACxB,QAAL,CAF/B,EAE+C;AAC7C,uBAAO,KAAP;AACD;AACF,aAtDgD,CAsD/C;AACF;;;AAGA,mBAAO,IAAP;AACD,WAtPoC,CAsPnC;;;AAGF,cAAIyB,8BAA8B,GAAGnD,kBAAkB,CAACyB,sBAAD,EAAyB3B,qBAAzB,CAAvD;AACA,cAAIsD,uCAAuC,GAAGpD,kBAAkB,CAAC2C,+BAAD,EAAkC5C,iCAAlC,CAAhE,CA1PqC,CA0PiG;;AAEtI,cAAIsD,0BAA0B,GAAG,IAAIjL,GAAJ,EAAjC,CA5PqC,CA4PO;AAC5C;AACA;;AAEA,mBAASkL,qBAAT,CAA+BC,SAA/B,EAA0C;AACxC,gBAAIC,QAAQ,GAAGD,SAAS,CAACE,IAAzB;AACA,gBAAIC,oBAAoB,GAAG,KAA3B;;AAEA,mBAAOF,QAAQ,CAACvB,KAAT,KAAmBpL,IAA1B,EAAgC;AAC9B,kBAAI2M,QAAQ,CAAC1M,IAAT,KAAkB,UAAtB,EAAkC;AAChC4M,gBAAAA,oBAAoB,GAAGF,QAAQ,CAACvB,KAAT,CAAezK,MAAf,IAAyB,IAAzB,IAAiCgM,QAAQ,CAACvB,KAAT,CAAezK,MAAf,CAAsBV,IAAtB,KAA+B,iBAAvF;AACD;;AAED0M,cAAAA,QAAQ,GAAGA,QAAQ,CAAChC,KAApB;AACD;;AAED,mBAAOkC,oBAAP;AACD,WA7QoC,CA6QnC;AACF;;;AAGA,cAAIC,YAAY,GAAG,IAAIvL,GAAJ,EAAnB;AACAwL,UAAAA,6BAA6B,CAACzC,KAAD,CAA7B;;AAEA,mBAASyC,6BAAT,CAAuCrC,YAAvC,EAAqD;AACnD,gBAAIpI,yBAAyB,GAAG,IAAhC;AACA,gBAAIC,iBAAiB,GAAG,KAAxB;AACA,gBAAIC,cAAc,GAAGC,SAArB;;AAEA,gBAAI;AACF,mBAAK,IAAIC,SAAS,GAAGgI,YAAY,CAACe,UAAb,CAAwB7I,MAAM,CAACC,QAA/B,GAAhB,EAA4DC,KAAjE,EAAwE,EAAER,yBAAyB,GAAG,CAACQ,KAAK,GAAGJ,SAAS,CAACK,IAAV,EAAT,EAA2BC,IAAzD,CAAxE,EAAwIV,yBAAyB,GAAG,IAApK,EAA0K;AACxK,oBAAIoK,SAAS,GAAG5J,KAAK,CAACI,KAAtB,CADwK,CAGxK;AACA;;AACA,oBAAI,CAACwJ,SAAS,CAAC7B,QAAf,EAAyB;AACvB;AACD;;AAED,oBAAI,CAACL,UAAU,CAACpI,GAAX,CAAesK,SAAS,CAAC7B,QAAV,CAAmBP,KAAlC,CAAL,EAA+C;AAC7C;AACD,iBAXuK,CAWtK;AACF;;;AAGA,oBAAI0C,aAAa,GAAG7B,2BAA2B,CAACnL,IAAD,EAAO0M,SAAS,CAACf,UAAjB,CAA/C;AACA,oBAAIsB,cAAc,GAAGC,aAAa,CAACF,aAAD,CAAlC;AACA,oBAAIG,UAAU,GAAGC,sBAAsB,CAACH,cAAD,CAAvC,CAjBwK,CAiB/G;;AAEzD,qBAAK;AACLhD,gBAAAA,QAAQ,IAAI;AACZgD,gBAAAA,cAAc,CAAChN,IAAf,KAAwB,YADxB,IACwCgN,cAAc,CAACtM,MAAf,CAAsBV,IAAtB,KAA+B,kBADvE,IAC6F,CAACgN,cAAc,CAACtM,MAAf,CAAsBR,QADpH,IACgI8M,cAAc,CAACtM,MAAf,CAAsBP,QAAtB,CAA+BH,IAA/B,KAAwC,YADxK,IACwLgN,cAAc,CAACtM,MAAf,CAAsBP,QAAtB,CAA+BF,IAA/B,KAAwC,SADhO,IAC6O;AAC7OuM,gBAAAA,qBAAqB,CAACC,SAAD,CAHrB,EAGkC;AAChCF,kBAAAA,0BAA0B,CAACnJ,GAA3B,CAA+B8J,UAA/B,EAA2C;AACzCT,oBAAAA,SAAS,EAAEA,SAD8B;AAEzCO,oBAAAA,cAAc,EAAEA;AAFyB,mBAA3C;AAID;;AAED,oBAAIhC,GAAG,GAAGyB,SAAS,CAAC7B,QAAV,CAAmBG,IAAnB,CAAwB,CAAxB,CAAV;;AAEA,oBAAIC,GAAG,IAAI,IAAX,EAAiB;AACf;AACD,iBAjCuK,CAiCtK;;;AAGF,oBAAIA,GAAG,CAACjL,IAAJ,IAAY,IAAZ,IAAoBiL,GAAG,CAACjL,IAAJ,CAAS8H,IAAT,KAAkB9H,IAAI,CAACW,MAA/C,EAAuD;AACrD;AACD,iBAtCuK,CAsCtK;;;AAGF,oBAAIsK,GAAG,CAAChL,IAAJ,KAAa,eAAjB,EAAkC;AAChC;AACD,iBA3CuK,CA2CtK;AACF;;;AAGA,oBAAI,CAAC6M,YAAY,CAAC1K,GAAb,CAAiB+K,UAAjB,CAAL,EAAmC;AACjC,sBAAItC,QAAQ,GAAG6B,SAAS,CAAC7B,QAAzB;AACA,sBAAIwC,QAAQ,GAAGf,8BAA8B,CAACzB,QAAD,CAA9B,IAA4C0B,uCAAuC,CAAC1B,QAAD,CAAlG;AACAiC,kBAAAA,YAAY,CAACzJ,GAAb,CAAiB8J,UAAjB,EAA6B;AAC3BE,oBAAAA,QAAQ,EAAEA,QADiB;AAE3B5B,oBAAAA,UAAU,EAAE,CAACiB,SAAD;AAFe,mBAA7B;AAID,iBAPD,MAOO;AACLI,kBAAAA,YAAY,CAAC5K,GAAb,CAAiBiL,UAAjB,EAA6B1B,UAA7B,CAAwCtK,IAAxC,CAA6CuL,SAA7C;AACD;AACF;AACF,aA3DD,CA2DE,OAAOvJ,GAAP,EAAY;AACZZ,cAAAA,iBAAiB,GAAG,IAApB;AACAC,cAAAA,cAAc,GAAGW,GAAjB;AACD,aA9DD,SA8DU;AACR,kBAAI;AACF,oBAAI,CAACb,yBAAD,IAA8BI,SAAS,CAACU,MAAV,IAAoB,IAAtD,EAA4D;AAC1DV,kBAAAA,SAAS,CAACU,MAAV;AACD;AACF,eAJD,SAIU;AACR,oBAAIb,iBAAJ,EAAuB;AACrB,wBAAMC,cAAN;AACD;AACF;AACF;;AAED,gBAAIiB,0BAA0B,GAAG,IAAjC;AACA,gBAAIC,kBAAkB,GAAG,KAAzB;AACA,gBAAIC,eAAe,GAAGlB,SAAtB;;AAEA,gBAAI;AACF,mBAAK,IAAImB,UAAU,GAAG8G,YAAY,CAACsB,WAAb,CAAyBpJ,MAAM,CAACC,QAAhC,GAAjB,EAA8DgB,MAAnE,EAA2E,EAAEJ,0BAA0B,GAAG,CAACI,MAAM,GAAGD,UAAU,CAACb,IAAX,EAAV,EAA6BC,IAA5D,CAA3E,EAA8IS,0BAA0B,GAAG,IAA3K,EAAiL;AAC/K,oBAAIyI,UAAU,GAAGrI,MAAM,CAACX,KAAxB;AACA6J,gBAAAA,6BAA6B,CAACb,UAAD,CAA7B;AACD;AACF,aALD,CAKE,OAAO/I,GAAP,EAAY;AACZO,cAAAA,kBAAkB,GAAG,IAArB;AACAC,cAAAA,eAAe,GAAGR,GAAlB;AACD,aARD,SAQU;AACR,kBAAI;AACF,oBAAI,CAACM,0BAAD,IAA+BG,UAAU,CAACR,MAAX,IAAqB,IAAxD,EAA8D;AAC5DQ,kBAAAA,UAAU,CAACR,MAAX;AACD;AACF,eAJD,SAIU;AACR,oBAAIM,kBAAJ,EAAwB;AACtB,wBAAMC,eAAN;AACD;AACF;AACF;AACF,WA1XoC,CA0XnC;;;AAGF6I,UAAAA,0BAA0B,CAACc,OAA3B,CAAmC,UAAUC,IAAV,EAAgBJ,UAAhB,EAA4B;AAC7D,gBAAIT,SAAS,GAAGa,IAAI,CAACb,SAArB;AAAA,gBACIO,cAAc,GAAGM,IAAI,CAACN,cAD1B;AAEA,gBAAIxB,UAAU,GAAGiB,SAAS,CAAC7B,QAAV,CAAmBY,UAApC,CAH6D,CAGb;AAChD;;AAEA,gBAAI+B,sBAAsB,GAAG,KAA7B;;AAEA,iBAAK,IAAI9B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,UAAU,CAACjI,MAA/B,EAAuCkI,CAAC,EAAxC,EAA4C;AAC1C,kBAAIC,UAAU,GAAGF,UAAU,CAACC,CAAD,CAAV,CAAcC,UAA/B;AACA,kBAAIhL,MAAM,GAAGgL,UAAU,CAAChL,MAAxB;;AAEA,kBAAIA,MAAM,IAAI,IAAV,IAAkB;AACtBA,cAAAA,MAAM,CAACV,IAAP,KAAgB,kBADZ,IACkC,CAACU,MAAM,CAACR,QAD1C,IACsDQ,MAAM,CAACP,QAAP,CAAgBH,IAAhB,KAAyB,YAD/E,IAC+FU,MAAM,CAACP,QAAP,CAAgBF,IAAhB,KAAyB,SADxH,IACqI;AACzIS,cAAAA,MAAM,CAACA,MAAP,CAAcV,IAAd,KAAuB,sBAFnB,IAE6CU,MAAM,CAACA,MAAP,CAAcsH,IAAd,KAAuBtH,MAFxE,EAEgF;AAC9E6M,gBAAAA,sBAAsB,GAAG,IAAzB;AACA;AACD;AACF,aAlB4D,CAkB3D;;;AAGF,gBAAIA,sBAAJ,EAA4B;AAC1B;AACD;;AAED1M,YAAAA,OAAO,CAACsG,MAAR,CAAe;AACbpH,cAAAA,IAAI,EAAEiN,cAAc,CAACtM,MAAf,CAAsBP,QADf;AAEbiH,cAAAA,OAAO,EAAE,oBAAoB8F,UAApB,GAAiC,6BAAjC,GAAiE,4DAAjE,GAAgI,oDAAhI,IAAwL,MAAMA,UAAN,GAAmB,iDAA3M,IAAgQ;AAF5P,aAAf;AAID,WA7BD,EA7XqC,CA0ZjC;AACJ;;AAEA,cAAIM,gBAAgB,GAAG,IAAI3L,GAAJ,EAAvB;;AAEA,mBAAS4L,qBAAT,CAA+BC,SAA/B,EAA0CzF,GAA1C,EAA+C;AAC7C,gBAAIuF,gBAAgB,CAACrL,GAAjB,CAAqB8F,GAArB,CAAJ,EAA+B;AAC7B;AACD;;AAEDuF,YAAAA,gBAAgB,CAACpL,GAAjB,CAAqB6F,GAArB;AACApH,YAAAA,OAAO,CAACsG,MAAR,CAAe;AACbpH,cAAAA,IAAI,EAAE2N,SADO;AAEbtG,cAAAA,OAAO,EAAE,yBAAyBa,GAAzB,GAA+B,oCAA/B,IAAuEpH,OAAO,CAACwG,SAAR,CAAkBwC,YAAlB,IAAkC,2BAAzG,IAAwI,gEAAxI,GAA2M,8DAA3M,GAA4Q,wDAA5Q,IAAwUhJ,OAAO,CAACwG,SAAR,CAAkBwC,YAAlB,IAAkC,GAA1W;AAFI,aAAf;AAID,WAzaoC,CAyanC;;;AAGF,cAAI8D,oBAAoB,GAAG,IAAI9L,GAAJ,EAA3B;AACAgL,UAAAA,YAAY,CAACQ,OAAb,CAAqB,UAAUO,KAAV,EAAiB3F,GAAjB,EAAsB;AACzC,gBAAImF,QAAQ,GAAGQ,KAAK,CAACR,QAArB;AAAA,gBACI5B,UAAU,GAAGoC,KAAK,CAACpC,UADvB;;AAGA,gBAAI4B,QAAJ,EAAc;AACZO,cAAAA,oBAAoB,CAACvL,GAArB,CAAyB6F,GAAzB;AACD;;AAEDuD,YAAAA,UAAU,CAAC6B,OAAX,CAAmB,UAAUZ,SAAV,EAAqB;AACtC,kBAAIA,SAAS,CAACiB,SAAd,EAAyB;AACvBD,gBAAAA,qBAAqB,CAAChB,SAAS,CAACiB,SAAX,EAAsBzF,GAAtB,CAArB;AACD;AACF,aAJD;AAKD,WAbD;;AAeA,cAAIuF,gBAAgB,CAAC7L,IAAjB,GAAwB,CAA5B,EAA+B;AAC7B;AACA;AACD;;AAED,cAAI,CAACwI,wBAAL,EAA+B;AAC7B;AACA;AACA,gBAAI0D,+BAA+B,GAAG,IAAtC;AACAhB,YAAAA,YAAY,CAACQ,OAAb,CAAqB,UAAUS,KAAV,EAAiB7F,GAAjB,EAAsB;AACzC,kBAAImF,QAAQ,GAAGU,KAAK,CAACV,QAArB;AAAA,kBACI5B,UAAU,GAAGsC,KAAK,CAACtC,UADvB;;AAGA,kBAAIqC,+BAAJ,EAAqC;AACnC;AACD;;AAEDrC,cAAAA,UAAU,CAAC6B,OAAX,CAAmB,UAAUZ,SAAV,EAAqB;AACtC,oBAAIoB,+BAAJ,EAAqC;AACnC;AACD;;AAED,oBAAI3L,EAAE,GAAGuK,SAAS,CAACf,UAAnB;AACA,oBAAIqC,UAAU,GAAGnF,iBAAiB,CAACzG,GAAlB,CAAsBD,EAAtB,CAAjB;;AAEA,oBAAI,CAAC6L,UAAL,EAAiB;AACf;AACD;;AAED,oBAAI/B,OAAO,GAAGS,SAAS,CAACE,IAAxB;;AAEA,uBAAOX,OAAO,CAAChM,IAAR,KAAiB,UAAxB,EAAoC;AAClCgM,kBAAAA,OAAO,GAAGA,OAAO,CAACtB,KAAlB;AACD;;AAED,oBAAIsD,sBAAsB,GAAGhC,OAAO,CAACb,KAAR,KAAkBpL,IAA/C;;AAEA,oBAAIiO,sBAAJ,EAA4B;AAC1B;AACAH,kBAAAA,+BAA+B,GAAG5F,GAAlC;AACD;AACF,eAxBD;AAyBD,aAjCD;;AAmCA,gBAAI4F,+BAAJ,EAAqC;AACnC,kBAAII,qBAAqB,GAAGC,sBAAsB,CAAC;AACjDrB,gBAAAA,YAAY,EAAEA,YADmC;AAEjDsB,gBAAAA,oBAAoB,EAAE,EAF2B;AAGjDR,gBAAAA,oBAAoB,EAAEA,oBAH2B;AAIjDS,gBAAAA,oBAAoB,EAAE,IAAIvM,GAAJ,EAJ2B;AAKjDmI,gBAAAA,QAAQ,EAAE;AALuC,eAAD,CAAlD;AAAA,kBAOIqE,sBAAsB,GAAGJ,qBAAqB,CAACK,qBAPnD;;AASAzN,cAAAA,OAAO,CAACsG,MAAR,CAAe;AACbpH,gBAAAA,IAAI,EAAEA,IAAI,CAACW,MAAL,CAAYgH,MADL;AAEbN,gBAAAA,OAAO,EAAE,gBAAgB0C,gBAAhB,GAAmC,uBAAnC,GAA6D+D,+BAA7D,GAA+F,KAA/F,GAAuG,iFAAvG,GAA2L,qBAA3L,GAAmNQ,sBAAsB,CAACE,IAAvB,CAA4B,IAA5B,CAAnN,IAAwP,mCAAmCzE,gBAAnC,GAAsD,QAA9S,CAFI;AAGb0E,gBAAAA,GAAG,EAAE,UAAUC,KAAV,EAAiB;AACpB,yBAAOA,KAAK,CAACC,eAAN,CAAsB3O,IAAtB,EAA4B,QAAQsO,sBAAsB,CAACE,IAAvB,CAA4B,IAA5B,CAAR,GAA4C,GAAxE,CAAP;AACD;AALY,eAAf;AAOD;;AAED;AACD;;AAED,cAAIJ,oBAAoB,GAAG,EAA3B;AACA,cAAIC,oBAAoB,GAAG,IAAIvM,GAAJ,EAA3B;;AAEA,cAAIsI,wBAAwB,CAACnK,IAAzB,KAAkC,iBAAtC,EAAyD;AACvD;AACA;AACA;AACAa,YAAAA,OAAO,CAACsG,MAAR,CAAe;AACbpH,cAAAA,IAAI,EAAEoK,wBADO;AAEb/C,cAAAA,OAAO,EAAE,gBAAgBvG,OAAO,CAACwG,SAAR,CAAkBwC,YAAlB,CAAhB,GAAkD,gBAAlD,GAAqE,8DAArE,GAAsI,4DAAtI,GAAqM;AAFjM,aAAf;AAID,WARD,MAQO;AACLM,YAAAA,wBAAwB,CAACmB,QAAzB,CAAkC+B,OAAlC,CAA0C,UAAUsB,sBAAV,EAAkC;AAC1E;AACA,kBAAIA,sBAAsB,KAAK,IAA/B,EAAqC;AACnC;AACD,eAJyE,CAIxE;;;AAGF,kBAAIA,sBAAsB,CAAC3O,IAAvB,KAAgC,eAApC,EAAqD;AACnDa,gBAAAA,OAAO,CAACsG,MAAR,CAAe;AACbpH,kBAAAA,IAAI,EAAE4O,sBADO;AAEbvH,kBAAAA,OAAO,EAAE,gBAAgBvG,OAAO,CAACwG,SAAR,CAAkBwC,YAAlB,CAAhB,GAAkD,gBAAlD,GAAqE,uDAArE,GAA+H,8CAA/H,GAAgL;AAF5K,iBAAf;AAIA;AACD,eAbyE,CAaxE;AACF;;;AAGA,kBAAI+E,kBAAJ;;AAEA,kBAAI;AACFA,gBAAAA,kBAAkB,GAAGzB,sBAAsB,CAACwB,sBAAD,CAA3C;AACD,eAFD,CAEE,OAAOE,KAAP,EAAc;AACd,oBAAI,wBAAwBhP,IAAxB,CAA6BgP,KAAK,CAACzH,OAAnC,CAAJ,EAAiD;AAC/C,sBAAIuH,sBAAsB,CAAC3O,IAAvB,KAAgC,SAApC,EAA+C;AAC7C,wBAAI6M,YAAY,CAAC1K,GAAb,CAAiBwM,sBAAsB,CAAC1L,KAAxC,CAAJ,EAAoD;AAClDpC,sBAAAA,OAAO,CAACsG,MAAR,CAAe;AACbpH,wBAAAA,IAAI,EAAE4O,sBADO;AAEbvH,wBAAAA,OAAO,EAAE,SAASuH,sBAAsB,CAACG,GAAhC,GAAsC,qCAAtC,GAA8E,4BAA9E,IAA8G,6BAA6BH,sBAAsB,CAAC1L,KAApD,GAA4D,wBAA1K;AAFI,uBAAf;AAID,qBALD,MAKO;AACLpC,sBAAAA,OAAO,CAACsG,MAAR,CAAe;AACbpH,wBAAAA,IAAI,EAAE4O,sBADO;AAEbvH,wBAAAA,OAAO,EAAE,SAASuH,sBAAsB,CAACG,GAAhC,GAAsC,qCAAtC,GAA8E;AAF1E,uBAAf;AAID;AACF,mBAZD,MAYO;AACLjO,oBAAAA,OAAO,CAACsG,MAAR,CAAe;AACbpH,sBAAAA,IAAI,EAAE4O,sBADO;AAEbvH,sBAAAA,OAAO,EAAE,gBAAgBvG,OAAO,CAACwG,SAAR,CAAkBwC,YAAlB,CAAhB,GAAkD,SAAlD,GAA8D,8CAA9D,GAA+G;AAF3G,qBAAf;AAID;;AAED;AACD,iBArBD,MAqBO;AACL,wBAAMgF,KAAN;AACD;AACF;;AAED,kBAAIE,OAAO,GAAGJ,sBAAd;;AAEA,qBAAOI,OAAO,CAAC/O,IAAR,KAAiB,kBAAxB,EAA4C;AAC1C+O,gBAAAA,OAAO,GAAGA,OAAO,CAAC1O,MAAlB;AACD;;AAED,kBAAI2O,qBAAqB,GAAG,CAACxE,cAAc,CAAC2B,OAAf,CAAuB8C,IAAvB,CAA4B,UAAU7C,GAAV,EAAe;AACtE,uBAAOA,GAAG,CAACV,UAAJ,KAAmBqD,OAA1B;AACD,eAF4B,CAA7B,CAtD0E,CAwDtE;;AAEJZ,cAAAA,oBAAoB,CAACjN,IAArB,CAA0B;AACxB+G,gBAAAA,GAAG,EAAE2G,kBADmB;AAExB7O,gBAAAA,IAAI,EAAE4O;AAFkB,eAA1B;;AAKA,kBAAI,CAACK,qBAAL,EAA4B;AAC1BZ,gBAAAA,oBAAoB,CAAChM,GAArB,CAAyBwM,kBAAzB;AACD;AACF,aAlED;AAmED;;AAED,cAAIM,sBAAsB,GAAGhB,sBAAsB,CAAC;AAClDrB,YAAAA,YAAY,EAAEA,YADoC;AAElDsB,YAAAA,oBAAoB,EAAEA,oBAF4B;AAGlDR,YAAAA,oBAAoB,EAAEA,oBAH4B;AAIlDS,YAAAA,oBAAoB,EAAEA,oBAJ4B;AAKlDpE,YAAAA,QAAQ,EAAEA;AALwC,WAAD,CAAnD;AAAA,cAOIsE,qBAAqB,GAAGY,sBAAsB,CAACZ,qBAPnD;AAAA,cAQIa,uBAAuB,GAAGD,sBAAsB,CAACC,uBARrD;AAAA,cASIC,mBAAmB,GAAGF,sBAAsB,CAACE,mBATjD;AAAA,cAUIC,qBAAqB,GAAGH,sBAAsB,CAACG,qBAVnD;;AAYA,cAAIC,YAAY,GAAGD,qBAAqB,CAAC1N,IAAtB,GAA6ByN,mBAAmB,CAACzN,IAAjD,GAAwDwN,uBAAuB,CAACxN,IAAnG;;AAEA,cAAI2N,YAAY,KAAK,CAArB,EAAwB;AACtB;AACA;AACA,gBAAIC,aAAa,GAAGC,4BAA4B,CAAC;AAC/CrB,cAAAA,oBAAoB,EAAEA,oBADyB;AAE/ChE,cAAAA,wBAAwB,EAAEA,wBAFqB;AAG/CK,cAAAA,cAAc,EAAEA,cAH+B;AAI/CH,cAAAA,KAAK,EAAEA;AAJwC,aAAD,CAAhD;AAMAkF,YAAAA,aAAa,CAAClC,OAAd,CAAsB,UAAUoC,KAAV,EAAiB;AACrC,kBAAItG,EAAE,GAAGsG,KAAK,CAACtG,EAAf;AAAA,kBACIuG,kBAAkB,GAAGD,KAAK,CAACC,kBAD/B;AAEA,kBAAItI,OAAO,GAAG,UAAU+B,EAAE,CAAClJ,IAAH,CAAQA,IAAlB,GAAyB,uCAAzB,IAAoE6J,gBAAgB,GAAG,iBAAnB,GAAuCK,wBAAwB,CAACwF,GAAzB,CAA6BC,KAA7B,CAAmCC,IAA1E,GAAiF,IAArJ,IAA6J,yBAA3K;;AAEA,kBAAIH,kBAAJ,EAAwB;AACtBtI,gBAAAA,OAAO,IAAI,oBAAoB,eAAe+B,EAAE,CAAClJ,IAAH,CAAQA,IAAvB,GAA8B,+CAAlD,CAAX;AACD,eAFD,MAEO;AACLmH,gBAAAA,OAAO,IAAI,yBAAyB0C,gBAAzB,GAA4C,aAA5C,IAA6D,8BAA8BX,EAAE,CAAClJ,IAAH,CAAQA,IAAtC,GAA6C,+CAA1G,CAAX;AACD,eAToC,CASnC;AACF;;;AAGAY,cAAAA,OAAO,CAACsG,MAAR,CAAe;AACb;AACApH,gBAAAA,IAAI,EAAEoJ,EAAE,CAACpJ,IAFI;AAGbqH,gBAAAA,OAAO,EAAEA,OAHI;AAIboH,gBAAAA,GAAG,EAAE,UAAUC,KAAV,EAAiB;AACpB;AACA;AACA,sBAAIiB,kBAAkB,IAAIvG,EAAE,CAACnJ,IAAH,KAAY,UAAtC,EAAkD;AAChD,2BAAO,CAAC;AACRyO,oBAAAA,KAAK,CAACqB,gBAAN,CAAuB3G,EAAE,CAACpJ,IAAH,CAAQ8H,IAA/B,EAAqC,cAArC,CADO,EAC+C;AACtD;AACA;AACA;AACA4G,oBAAAA,KAAK,CAACC,eAAN,CAAsBvF,EAAE,CAACpJ,IAAH,CAAQ8H,IAA9B,EAAoC,GAApC,CALO,CAAP;AAMD;AACF;AAfY,eAAf;AAiBD,aA9BD;AA+BA;AACD,WAtoBoC,CAsoBnC;AACF;AACA;AACA;AACA;AACA;;;AAGA,cAAI,CAACmC,QAAD,IAAaoF,mBAAmB,CAACzN,IAApB,GAA2B,CAA5C,EAA+C;AAC7C2M,YAAAA,qBAAqB,GAAGJ,sBAAsB,CAAC;AAC7CrB,cAAAA,YAAY,EAAEA,YAD+B;AAE7CsB,cAAAA,oBAAoB,EAAE,EAFuB;AAG7C;AACAR,cAAAA,oBAAoB,EAAEA,oBAJuB;AAK7CS,cAAAA,oBAAoB,EAAEA,oBALuB;AAM7CpE,cAAAA,QAAQ,EAAEA;AANmC,aAAD,CAAtB,CAOrBsE,qBAPH;AAQD,WAvpBoC,CAupBnC;;;AAGF,mBAASyB,2BAAT,GAAuC;AACrC,gBAAI5B,oBAAoB,CAAC5K,MAArB,KAAgC,CAApC,EAAuC;AACrC,qBAAO,IAAP;AACD;;AAED,gBAAIyM,eAAe,GAAG7B,oBAAoB,CAAC/E,GAArB,CAAyB,UAAU6G,GAAV,EAAe;AAC5D,qBAAOA,GAAG,CAAChI,GAAX;AACD,aAFqB,CAAtB;AAGA,gBAAIiI,qBAAqB,GAAGF,eAAe,CAACG,KAAhB,GAAwBC,IAAxB,EAA5B;AACA,mBAAOJ,eAAe,CAACzB,IAAhB,CAAqB,GAArB,MAA8B2B,qBAAqB,CAAC3B,IAAtB,CAA2B,GAA3B,CAArC;AACD;;AAED,cAAIwB,2BAA2B,EAA/B,EAAmC;AACjCzB,YAAAA,qBAAqB,CAAC8B,IAAtB;AACD;;AAED,mBAASC,iBAAT,CAA2BC,IAA3B,EAAiCC,YAAjC,EAA+CC,KAA/C,EAAsDC,OAAtD,EAA+D;AAC7D,gBAAIH,IAAI,CAAC3O,IAAL,KAAc,CAAlB,EAAqB;AACnB,qBAAO,IAAP;AACD;;AAED,mBAAO,CAAC2O,IAAI,CAAC3O,IAAL,GAAY,CAAZ,GAAgB,EAAhB,GAAqB4O,YAAY,GAAG,GAArC,IAA4CC,KAA5C,GAAoD,GAApD,IAA2DF,IAAI,CAAC3O,IAAL,GAAY,CAAZ,GAAgB,cAAhB,GAAiC,YAA5F,IAA4G,IAA5G,GAAmH+O,WAAW,CAAC7F,KAAK,CAAC8B,IAAN,CAAW2D,IAAX,EAAiBF,IAAjB,GAAwBhH,GAAxB,CAA4B,UAAUnJ,IAAV,EAAgB;AAChL,qBAAO,MAAMA,IAAN,GAAa,GAApB;AACD,aAFqI,CAAD,CAA9H,IAEA,cAAcwQ,OAAd,GAAwB,GAAxB,IAA+BH,IAAI,CAAC3O,IAAL,GAAY,CAAZ,GAAgB,MAAhB,GAAyB,IAAxD,IAAgE,kCAFhE,CAAP;AAGD;;AAED,cAAIgP,YAAY,GAAG,EAAnB;;AAEA,cAAIxB,uBAAuB,CAACxN,IAAxB,GAA+B,CAAnC,EAAsC;AACpC,gBAAIiP,MAAM,GAAG,IAAb;AACA/F,YAAAA,KAAK,CAAC8B,IAAN,CAAWwC,uBAAuB,CAAC0B,IAAxB,EAAX,EAA2CxD,OAA3C,CAAmD,UAAUpF,GAAV,EAAe;AAChE,kBAAI2I,MAAM,KAAK,IAAf,EAAqB;AACnB;AACD;;AAED,kBAAI3I,GAAG,CAACgC,QAAJ,CAAa,UAAb,CAAJ,EAA8B;AAC5B2G,gBAAAA,MAAM,GAAG3I,GAAT;AACD;AACF,aARD;;AAUA,gBAAI2I,MAAM,KAAK,IAAf,EAAqB;AACnBD,cAAAA,YAAY,GAAG,2BAA2BC,MAA3B,GAAoC,8BAApC,GAAqE,wDAApF;AACD,aAFD,MAEO,IAAIxC,oBAAoB,CAACzM,IAArB,GAA4B,CAAhC,EAAmC;AACxC,kBAAIsO,GAAG,GAAGpF,KAAK,CAAC8B,IAAN,CAAWyB,oBAAX,EAAiC,CAAjC,CAAV,CADwC,CACO;AAC/C;;AAEA,kBAAI,CAAC/D,KAAK,CAACjH,GAAN,CAAUjB,GAAV,CAAc8N,GAAd,CAAL,EAAyB;AACvBU,gBAAAA,YAAY,GAAG,+BAA+BV,GAA/B,GAAqC,8BAArC,GAAsE,wDAArF;AACD;AACF;AACF,WA5sBoC,CA4sBnC;AACF;AACA;;;AAGA,cAAI,CAACU,YAAD,IAAiBvB,mBAAmB,CAACjN,GAApB,CAAwB,OAAxB,CAArB,EAAuD;AACrD,gBAAI2O,OAAO,GAAGjE,YAAY,CAAC5K,GAAb,CAAiB,OAAjB,CAAd;;AAEA,gBAAI6O,OAAO,IAAI,IAAf,EAAqB;AACnB;AACD;;AAED,gBAAIC,IAAI,GAAGD,OAAO,CAACtF,UAAnB;;AAEA,gBAAI,CAACX,KAAK,CAACC,OAAN,CAAciG,IAAd,CAAL,EAA0B;AACxB;AACD;;AAED,gBAAIC,wBAAwB,GAAG,IAA/B;;AAEA,iBAAK,IAAIvF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsF,IAAI,CAACxN,MAAzB,EAAiCkI,CAAC,EAAlC,EAAsC;AACpC,kBAAIW,GAAG,GAAG2E,IAAI,CAACtF,CAAD,CAAd;AACA,kBAAIvJ,EAAE,GAAGgJ,2BAA2B,CAACV,cAAc,CAACW,KAAhB,EAAuBiB,GAAG,CAACV,UAA3B,CAApC;;AAEA,kBAAI,CAACxJ,EAAL,EAAS;AACP8O,gBAAAA,wBAAwB,GAAG,KAA3B;AACA;AACD;;AAED,kBAAItQ,MAAM,GAAGwB,EAAE,CAACxB,MAAhB;;AAEA,kBAAIA,MAAM,IAAI,IAAd,EAAoB;AAClBsQ,gBAAAA,wBAAwB,GAAG,KAA3B;AACA;AACD;;AAED,kBAAItQ,MAAM,CAACV,IAAP,KAAgB,kBAApB,EAAwC;AACtCgR,gBAAAA,wBAAwB,GAAG,KAA3B;AACA;AACD;AACF;;AAED,gBAAIA,wBAAJ,EAA8B;AAC5BL,cAAAA,YAAY,GAAG,mEAAmE,gEAAnE,IAAuI,SAAS7G,gBAAT,GAA4B,0CAAnK,KAAkN,YAAYjJ,OAAO,CAACwG,SAAR,CAAkBwC,YAAlB,CAAZ,GAA8C,GAAhQ,CAAf;AACD;AACF;;AAED,cAAI,CAAC8G,YAAD,IAAiBvB,mBAAmB,CAACzN,IAApB,GAA2B,CAAhD,EAAmD;AACjD;AACA;AACA,gBAAIsP,kBAAkB,GAAG,IAAzB;AACA7B,YAAAA,mBAAmB,CAAC/B,OAApB,CAA4B,UAAU6D,UAAV,EAAsB;AAChD,kBAAID,kBAAJ,EAAwB;AACtB;AACD,eAH+C,CAG9C;;;AAGF,kBAAIE,WAAW,GAAG3G,cAAc,CAACpH,GAAf,CAAmBnB,GAAnB,CAAuBiP,UAAvB,CAAlB;AACA,kBAAIE,OAAO,GAAGvE,YAAY,CAAC5K,GAAb,CAAiBiP,UAAjB,CAAd;;AAEA,kBAAIE,OAAO,CAAC5F,UAAR,CAAmB,CAAnB,EAAsBZ,QAAtB,KAAmCuG,WAAvC,EAAoD;AAClD;AACD,eAX+C,CAW9C;;;AAGF,kBAAInG,GAAG,GAAGmG,WAAW,CAACpG,IAAZ,CAAiB,CAAjB,CAAV;;AAEA,kBAAIC,GAAG,IAAI,IAAP,IAAeA,GAAG,CAAC/K,IAAJ,IAAY,IAA3B,IAAmC+K,GAAG,CAAChL,IAAJ,KAAa,WAApD,EAAiE;AAC/D;AACD,eAlB+C,CAkB9C;;;AAGF,kBAAIqR,cAAc,GAAG,KAArB;AACA,kBAAInP,EAAJ;;AAEA,mBAAK,IAAIoP,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,OAAO,CAAC5F,UAAR,CAAmBjI,MAA3C,EAAmD+N,GAAG,EAAtD,EAA0D;AACxDpP,gBAAAA,EAAE,GAAGkP,OAAO,CAAC5F,UAAR,CAAmB8F,GAAnB,EAAwB5F,UAA7B;;AAEA,oBAAIxJ,EAAE,IAAI,IAAN,IAAcA,EAAE,CAACxB,MAAH,IAAa,IAA3B,IAAmCwB,EAAE,CAACxB,MAAH,CAAUV,IAAV,KAAmB,gBAAtD,IAA0EkC,EAAE,CAACxB,MAAH,CAAUgH,MAAV,KAAqBxF,EAAnG,EAAuG;AACrGmP,kBAAAA,cAAc,GAAG,IAAjB;AACA;AACD;AACF;;AAED,kBAAI,CAACA,cAAL,EAAqB;AACnB;AACD,eAnC+C,CAmC9C;AACF;AACA;;;AAGAJ,cAAAA,kBAAkB,GAAGC,UAArB;AACD,aAzCD;;AA2CA,gBAAID,kBAAkB,KAAK,IAA3B,EAAiC;AAC/BN,cAAAA,YAAY,GAAG,UAAUM,kBAAV,GAA+B,uBAA/B,GAAyD,4CAAzD,GAAwG,0CAAvH;AACD;AACF;;AAED,cAAI,CAACN,YAAD,IAAiBvB,mBAAmB,CAACzN,IAApB,GAA2B,CAAhD,EAAmD;AACjD,gBAAI4P,sBAAsB,GAAG,IAA7B;AACAnC,YAAAA,mBAAmB,CAAC/B,OAApB,CAA4B,UAAU6D,UAAV,EAAsB;AAChD,kBAAIK,sBAAsB,KAAK,IAA/B,EAAqC;AACnC;AACD;;AAED,kBAAIH,OAAO,GAAGvE,YAAY,CAAC5K,GAAb,CAAiBiP,UAAjB,CAAd;AACA,kBAAI1F,UAAU,GAAG4F,OAAO,CAAC5F,UAAzB;AACA,kBAAItJ,EAAJ;AACA,kBAAIsP,SAAJ;;AAEA,mBAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGjG,UAAU,CAACjI,MAAnC,EAA2CkO,GAAG,EAA9C,EAAkD;AAChDvP,gBAAAA,EAAE,GAAGsJ,UAAU,CAACiG,GAAD,CAAV,CAAgB/F,UAArB;AACA8F,gBAAAA,SAAS,GAAGtP,EAAE,CAACxB,MAAf,CAFgD,CAEzB;;AAEvB,uBAAO8Q,SAAS,IAAI,IAAb,IAAqBA,SAAS,KAAKhH,cAAc,CAACW,KAAzD,EAAgE;AAC9D,sBAAIqG,SAAS,CAACxR,IAAV,KAAmB,gBAAvB,EAAyC;AACvC,wBAAI0R,0BAA0B,GAAG9I,iBAAiB,CAAC3G,GAAlB,CAAsBuP,SAAS,CAAC9J,MAAhC,CAAjC;;AAEA,wBAAIgK,0BAA0B,IAAI,IAAlC,EAAwC;AACtC,0BAAIA,0BAA0B,CAACzR,IAA3B,KAAoCiR,UAAxC,EAAoD;AAClD;AACAK,wBAAAA,sBAAsB,GAAG;AACvBL,0BAAAA,UAAU,EAAEA,UADW;AAEvBS,0BAAAA,MAAM,EAAEH,SAAS,CAAC9J,MAAV,CAAiBzH,IAFF;AAGvB2R,0BAAAA,IAAI,EAAE;AAHiB,yBAAzB;AAKD,uBAPD,MAOO,IAAI9I,cAAc,CAAC3G,GAAf,CAAmBD,EAAnB,CAAJ,EAA4B;AACjC;AACAqP,wBAAAA,sBAAsB,GAAG;AACvBL,0BAAAA,UAAU,EAAEA,UADW;AAEvBS,0BAAAA,MAAM,EAAEH,SAAS,CAAC9J,MAAV,CAAiBzH,IAFF;AAGvB2R,0BAAAA,IAAI,EAAE;AAHiB,yBAAzB;AAKD,uBAPM,MAOA;AACL,4BAAIhH,QAAQ,GAAGY,UAAU,CAACiG,GAAD,CAAV,CAAgB7G,QAA/B;;AAEA,4BAAIA,QAAQ,IAAI,IAAhB,EAAsB;AACpB;AACA;AACA;AACA,8BAAII,GAAG,GAAGJ,QAAQ,CAACG,IAAT,CAAc,CAAd,CAAV;;AAEA,8BAAIC,GAAG,IAAI,IAAP,IAAeA,GAAG,CAAChL,IAAJ,KAAa,WAAhC,EAA6C;AAC3CuR,4BAAAA,sBAAsB,GAAG;AACvBL,8BAAAA,UAAU,EAAEA,UADW;AAEvBS,8BAAAA,MAAM,EAAEH,SAAS,CAAC9J,MAAV,CAAiBzH,IAFF;AAGvB2R,8BAAAA,IAAI,EAAE;AAHiB,6BAAzB;AAKD;AACF;AACF;;AAED;AACD;AACF;;AAEDJ,kBAAAA,SAAS,GAAGA,SAAS,CAAC9Q,MAAtB;AACD;;AAED,oBAAI6Q,sBAAsB,KAAK,IAA/B,EAAqC;AACnC;AACD;AACF;AACF,aA/DD;;AAiEA,gBAAIA,sBAAsB,KAAK,IAA/B,EAAqC;AACnC,sBAAQA,sBAAsB,CAACK,IAA/B;AACE,qBAAK,SAAL;AACEjB,kBAAAA,YAAY,GAAG,wEAAwE,SAASY,sBAAsB,CAACI,MAAhC,GAAyC,cAAjH,KAAoI,uBAAuBJ,sBAAsB,CAACL,UAA9C,GAA2D,IAA/L,CAAf;AACA;;AAEF,qBAAK,eAAL;AACEP,kBAAAA,YAAY,GAAG,UAAUY,sBAAsB,CAACI,MAAjC,GAA0C,cAA1C,IAA4D,uBAAuBJ,sBAAsB,CAACL,UAA9C,GAA2D,KAAvH,IAAgI,4DAAhI,IAAgM,WAAWK,sBAAsB,CAACL,UAAlC,GAA+C,mBAA/O,CAAf;AACA;;AAEF,qBAAK,SAAL;AACEP,kBAAAA,YAAY,GAAG,2CAA2CY,sBAAsB,CAACI,MAAlE,GAA2E,GAA3E,GAAiFJ,sBAAsB,CAACL,UAAvB,CAAkCW,SAAlC,CAA4C,CAA5C,EAA+C,CAA/C,CAAjF,GAAqI,8BAArI,GAAsKN,sBAAsB,CAACL,UAA7L,GAA0M,GAA1M,IAAiN,cAAcK,sBAAsB,CAACI,MAArC,GAA8C,SAA/P,CAAf;AACA;;AAEF;AACE,wBAAM,IAAIG,KAAJ,CAAU,eAAV,CAAN;AAdJ;AAgBD;AACF;;AAEDjR,UAAAA,OAAO,CAACsG,MAAR,CAAe;AACbpH,YAAAA,IAAI,EAAEoK,wBADO;AAEb/C,YAAAA,OAAO,EAAE,gBAAgBvG,OAAO,CAACwG,SAAR,CAAkBwC,YAAlB,CAAhB,GAAkD,OAAlD,KAA8D;AACvEwG,YAAAA,iBAAiB,CAACjB,mBAAD,EAAsB,GAAtB,EAA2B,SAA3B,EAAsC,SAAtC,CAAjB,IAAqEiB,iBAAiB,CAAClB,uBAAD,EAA0B,IAA1B,EAAgC,aAAhC,EAA+C,SAA/C,CAAtF,IAAmJkB,iBAAiB,CAAChB,qBAAD,EAAwB,GAAxB,EAA6B,WAA7B,EAA0C,MAA1C,CAD3J,IACgNsB,YAH5M;AAIbnC,YAAAA,GAAG,EAAE,UAAUC,KAAV,EAAiB;AACpB;AACA,qBAAOA,KAAK,CAACsD,WAAN,CAAkB5H,wBAAlB,EAA4C,MAAMmE,qBAAqB,CAACC,IAAtB,CAA2B,IAA3B,CAAN,GAAyC,GAArF,CAAP;AACD;AAPY,WAAf;AASD;AACF;AA/7BkB,KAArB,CAvqBc,CAumDX;;AAEH,aAASL,sBAAT,CAAgC8D,KAAhC,EAAuC;AACrC,UAAInF,YAAY,GAAGmF,KAAK,CAACnF,YAAzB;AAAA,UACIsB,oBAAoB,GAAG6D,KAAK,CAAC7D,oBADjC;AAAA,UAEIR,oBAAoB,GAAGqE,KAAK,CAACrE,oBAFjC;AAAA,UAGIS,oBAAoB,GAAG4D,KAAK,CAAC5D,oBAHjC;AAAA,UAIIpE,QAAQ,GAAGgI,KAAK,CAAChI,QAJrB,CADqC,CAMrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAIiI,OAAO,GAAGC,aAAa,EAA3B;;AAEA,eAASA,aAAT,GAAyB;AACvB,eAAO;AACLC,UAAAA,UAAU,EAAE,KADP;AAEL;AACAC,UAAAA,sBAAsB,EAAE,KAHnB;AAIL;AACAC,UAAAA,qBAAqB,EAAE,KALlB;AAML;AACAC,UAAAA,QAAQ,EAAE,IAAIhR,GAAJ,EAPL,CAOe;;AAPf,SAAP;AAUD,OA5BoC,CA4BnC;AACF;;;AAGAuL,MAAAA,YAAY,CAACQ,OAAb,CAAqB,UAAUkF,CAAV,EAAatK,GAAb,EAAkB;AACrC,YAAIlI,IAAI,GAAGyS,qBAAqB,CAACP,OAAD,EAAUhK,GAAV,CAAhC;AACAlI,QAAAA,IAAI,CAACoS,UAAL,GAAkB,IAAlB;AACAM,QAAAA,oBAAoB,CAACR,OAAD,EAAUhK,GAAV,EAAe,UAAUvH,MAAV,EAAkB;AACnDA,UAAAA,MAAM,CAAC2R,qBAAP,GAA+B,IAA/B;AACD,SAFmB,CAApB;AAGD,OAND,EAhCqC,CAsCjC;AACJ;;AAEAlE,MAAAA,oBAAoB,CAACd,OAArB,CAA6B,UAAUqF,KAAV,EAAiB;AAC5C,YAAIzK,GAAG,GAAGyK,KAAK,CAACzK,GAAhB;AACA,YAAIlI,IAAI,GAAGyS,qBAAqB,CAACP,OAAD,EAAUhK,GAAV,CAAhC;AACAlI,QAAAA,IAAI,CAACqS,sBAAL,GAA8B,IAA9B;AACD,OAJD;AAKAzE,MAAAA,oBAAoB,CAACN,OAArB,CAA6B,UAAUpF,GAAV,EAAe;AAC1C,YAAIlI,IAAI,GAAGyS,qBAAqB,CAACP,OAAD,EAAUhK,GAAV,CAAhC;AACAlI,QAAAA,IAAI,CAACqS,sBAAL,GAA8B,IAA9B;AACD,OAHD,EA9CqC,CAiDjC;;AAEJ,eAASI,qBAAT,CAA+BG,QAA/B,EAAyCC,IAAzC,EAA+C;AAC7C,YAAI/B,IAAI,GAAG+B,IAAI,CAACC,KAAL,CAAW,GAAX,CAAX;AACA,YAAI9S,IAAI,GAAG4S,QAAX;AACA,YAAI1O,0BAA0B,GAAG,IAAjC;AACA,YAAIC,kBAAkB,GAAG,KAAzB;AACA,YAAIC,eAAe,GAAG3B,SAAtB;;AAEA,YAAI;AACF,eAAK,IAAI4B,UAAU,GAAGyM,IAAI,CAAClO,MAAM,CAACC,QAAR,CAAJ,EAAjB,EAA0C0B,MAA/C,EAAuD,EAAEL,0BAA0B,GAAG,CAACK,MAAM,GAAGF,UAAU,CAACtB,IAAX,EAAV,EAA6BC,IAA5D,CAAvD,EAA0HkB,0BAA0B,GAAG,IAAvJ,EAA6J;AAC3J,gBAAIgE,GAAG,GAAG3D,MAAM,CAACrB,KAAjB;AACA,gBAAI6P,KAAK,GAAG/S,IAAI,CAACuS,QAAL,CAAcrQ,GAAd,CAAkBgG,GAAlB,CAAZ;;AAEA,gBAAI,CAAC6K,KAAL,EAAY;AACVA,cAAAA,KAAK,GAAGZ,aAAa,EAArB;AACAnS,cAAAA,IAAI,CAACuS,QAAL,CAAclP,GAAd,CAAkB6E,GAAlB,EAAuB6K,KAAvB;AACD;;AAED/S,YAAAA,IAAI,GAAG+S,KAAP;AACD;AACF,SAZD,CAYE,OAAO5P,GAAP,EAAY;AACZgB,UAAAA,kBAAkB,GAAG,IAArB;AACAC,UAAAA,eAAe,GAAGjB,GAAlB;AACD,SAfD,SAeU;AACR,cAAI;AACF,gBAAI,CAACe,0BAAD,IAA+BG,UAAU,CAACjB,MAAX,IAAqB,IAAxD,EAA8D;AAC5DiB,cAAAA,UAAU,CAACjB,MAAX;AACD;AACF,WAJD,SAIU;AACR,gBAAIe,kBAAJ,EAAwB;AACtB,oBAAMC,eAAN;AACD;AACF;AACF;;AAED,eAAOpE,IAAP;AACD;;AAED,eAAS0S,oBAAT,CAA8BE,QAA9B,EAAwCC,IAAxC,EAA8CzJ,EAA9C,EAAkD;AAChD,YAAI0H,IAAI,GAAG+B,IAAI,CAACC,KAAL,CAAW,GAAX,CAAX;AACA,YAAI9S,IAAI,GAAG4S,QAAX;AACA,YAAInO,0BAA0B,GAAG,IAAjC;AACA,YAAIC,kBAAkB,GAAG,KAAzB;AACA,YAAIC,eAAe,GAAGlC,SAAtB;;AAEA,YAAI;AACF,eAAK,IAAImC,UAAU,GAAGkM,IAAI,CAAClO,MAAM,CAACC,QAAR,CAAJ,EAAjB,EAA0CgC,MAA/C,EAAuD,EAAEJ,0BAA0B,GAAG,CAACI,MAAM,GAAGD,UAAU,CAAC7B,IAAX,EAAV,EAA6BC,IAA5D,CAAvD,EAA0HyB,0BAA0B,GAAG,IAAvJ,EAA6J;AAC3J,gBAAIyD,GAAG,GAAGrD,MAAM,CAAC3B,KAAjB;AACA,gBAAI6P,KAAK,GAAG/S,IAAI,CAACuS,QAAL,CAAcrQ,GAAd,CAAkBgG,GAAlB,CAAZ;;AAEA,gBAAI,CAAC6K,KAAL,EAAY;AACV;AACD;;AAED3J,YAAAA,EAAE,CAAC2J,KAAD,CAAF;AACA/S,YAAAA,IAAI,GAAG+S,KAAP;AACD;AACF,SAZD,CAYE,OAAO5P,GAAP,EAAY;AACZuB,UAAAA,kBAAkB,GAAG,IAArB;AACAC,UAAAA,eAAe,GAAGxB,GAAlB;AACD,SAfD,SAeU;AACR,cAAI;AACF,gBAAI,CAACsB,0BAAD,IAA+BG,UAAU,CAACxB,MAAX,IAAqB,IAAxD,EAA8D;AAC5DwB,cAAAA,UAAU,CAACxB,MAAX;AACD;AACF,WAJD,SAIU;AACR,gBAAIsB,kBAAJ,EAAwB;AACtB,oBAAMC,eAAN;AACD;AACF;AACF;AACF,OAzHoC,CAyHnC;;;AAGF,UAAI0K,mBAAmB,GAAG,IAAIvN,GAAJ,EAA1B;AACA,UAAIkR,sBAAsB,GAAG,IAAIlR,GAAJ,EAA7B;AACAmR,MAAAA,mBAAmB,CAACf,OAAD,EAAU7C,mBAAV,EAA+B2D,sBAA/B,EAAuD,UAAU9K,GAAV,EAAe;AACvF,eAAOA,GAAP;AACD,OAFkB,CAAnB;;AAIA,eAAS+K,mBAAT,CAA6BjT,IAA7B,EAAmCkT,YAAnC,EAAiDC,eAAjD,EAAkEC,SAAlE,EAA6E;AAC3EpT,QAAAA,IAAI,CAACuS,QAAL,CAAcjF,OAAd,CAAsB,UAAUyF,KAAV,EAAiB7K,GAAjB,EAAsB;AAC1C,cAAI2K,IAAI,GAAGO,SAAS,CAAClL,GAAD,CAApB;;AAEA,cAAI6K,KAAK,CAACV,sBAAV,EAAkC;AAChC,gBAAIU,KAAK,CAACT,qBAAV,EAAiC;AAC/B;AACAa,cAAAA,eAAe,CAAC9Q,GAAhB,CAAoBwQ,IAApB;AACD,aAJ+B,CAI9B;AACF;AACA;;;AAGA;AACD;;AAED,cAAIE,KAAK,CAACX,UAAV,EAAsB;AACpB;AACAc,YAAAA,YAAY,CAAC7Q,GAAb,CAAiBwQ,IAAjB,EAFoB,CAEI;AACxB;;AAEA;AACD;;AAEDI,UAAAA,mBAAmB,CAACF,KAAD,EAAQG,YAAR,EAAsBC,eAAtB,EAAuC,UAAUE,QAAV,EAAoB;AAC5E,mBAAOR,IAAI,GAAG,GAAP,GAAaQ,QAApB;AACD,WAFkB,CAAnB;AAGD,SA1BD;AA2BD,OA9JoC,CA8JnC;;;AAGF,UAAI9E,qBAAqB,GAAG,EAA5B;AACA,UAAIa,uBAAuB,GAAG,IAAItN,GAAJ,EAA9B;AACA,UAAIwN,qBAAqB,GAAG,IAAIxN,GAAJ,EAA5B;AACAsM,MAAAA,oBAAoB,CAACd,OAArB,CAA6B,UAAUgG,KAAV,EAAiB;AAC5C,YAAIpL,GAAG,GAAGoL,KAAK,CAACpL,GAAhB,CAD4C,CAG5C;;AACA,YAAI8K,sBAAsB,CAAC5Q,GAAvB,CAA2B8F,GAA3B,CAAJ,EAAqC;AACnC,cAAIqG,qBAAqB,CAACgF,OAAtB,CAA8BrL,GAA9B,MAAuC,CAAC,CAA5C,EAA+C;AAC7C;AACAqG,YAAAA,qBAAqB,CAACpN,IAAtB,CAA2B+G,GAA3B;AACD,WAHD,MAGO;AACL;AACAoH,YAAAA,qBAAqB,CAACjN,GAAtB,CAA0B6F,GAA1B;AACD;AACF,SARD,MAQO;AACL,cAAI+B,QAAQ,IAAI,CAAC/B,GAAG,CAACgC,QAAJ,CAAa,UAAb,CAAb,IAAyC,CAACmE,oBAAoB,CAACjM,GAArB,CAAyB8F,GAAzB,CAA9C,EAA6E;AAC3E;AACA;AACA;AACA;AACA,gBAAIqG,qBAAqB,CAACgF,OAAtB,CAA8BrL,GAA9B,MAAuC,CAAC,CAA5C,EAA+C;AAC7CqG,cAAAA,qBAAqB,CAACpN,IAAtB,CAA2B+G,GAA3B;AACD;AACF,WARD,MAQO;AACL;AACAkH,YAAAA,uBAAuB,CAAC/M,GAAxB,CAA4B6F,GAA5B;AACD;AACF;AACF,OA1BD,EApKqC,CA8LjC;;AAEJmH,MAAAA,mBAAmB,CAAC/B,OAApB,CAA4B,UAAUpF,GAAV,EAAe;AACzCqG,QAAAA,qBAAqB,CAACpN,IAAtB,CAA2B+G,GAA3B;AACD,OAFD;AAGA,aAAO;AACLqG,QAAAA,qBAAqB,EAAEA,qBADlB;AAELa,QAAAA,uBAAuB,EAAEA,uBAFpB;AAGLE,QAAAA,qBAAqB,EAAEA,qBAHlB;AAILD,QAAAA,mBAAmB,EAAEA;AAJhB,OAAP;AAMD,KAlzDa,CAkzDZ;AACF;;;AAGA,aAASI,4BAAT,CAAsC+D,KAAtC,EAA6C;AAC3C,UAAIpF,oBAAoB,GAAGoF,KAAK,CAACpF,oBAAjC;AAAA,UACIhE,wBAAwB,GAAGoJ,KAAK,CAACpJ,wBADrC;AAAA,UAEIK,cAAc,GAAG+I,KAAK,CAAC/I,cAF3B;AAAA,UAGIH,KAAK,GAAGkJ,KAAK,CAAClJ,KAHlB;AAIA,UAAIkF,aAAa,GAAGpB,oBAAoB,CAAC/E,GAArB,CAAyB,UAAUoK,KAAV,EAAiB;AAC5D,YAAIvL,GAAG,GAAGuL,KAAK,CAACvL,GAAhB;AACA,YAAIwL,KAAK,GAAGjJ,cAAc,CAACpH,GAAf,CAAmBnB,GAAnB,CAAuBgG,GAAvB,CAAZ;;AAEA,YAAIwL,KAAK,IAAI,IAAb,EAAmB;AACjB,iBAAO,IAAP;AACD;;AAED,YAAI3H,MAAM,GAAG2H,KAAK,CAAC1I,IAAN,CAAW,CAAX,CAAb;;AAEA,YAAIe,MAAM,IAAI,IAAd,EAAoB;AAClB,iBAAO,IAAP;AACD,SAZ2D,CAY1D;AACF;;;AAGA,YAAIA,MAAM,CAAC9L,IAAP,KAAgB,UAAhB,IAA8B8L,MAAM,CAAC/L,IAAP,CAAYC,IAAZ,KAAqB,oBAAnD,IAA2E8L,MAAM,CAAC/L,IAAP,CAAY8H,IAAZ,IAAoB,IAA/F,KAAwGiE,MAAM,CAAC/L,IAAP,CAAY8H,IAAZ,CAAiB7H,IAAjB,KAA0B,yBAA1B,IAAuD8L,MAAM,CAAC/L,IAAP,CAAY8H,IAAZ,CAAiB7H,IAAjB,KAA0B,oBAAzL,CAAJ,EAAoN;AAClN,iBAAOyT,KAAP;AACD,SAlB2D,CAkB1D;;;AAGF,YAAI3H,MAAM,CAAC9L,IAAP,KAAgB,cAAhB,IAAkC8L,MAAM,CAAC/L,IAAP,CAAYC,IAAZ,KAAqB,qBAA3D,EAAkF;AAChF,iBAAOyT,KAAP;AACD;;AAED,eAAO,IAAP;AACD,OA1BmB,EA0BjBC,MA1BiB,CA0BVC,OA1BU,CAApB;;AA4BA,eAASC,mBAAT,CAA6BH,KAA7B,EAAoC;AAClC,YAAII,cAAc,GAAG,KAArB;;AAEA,aAAK,IAAIpI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgI,KAAK,CAACjI,UAAN,CAAiBjI,MAArC,EAA6CkI,CAAC,EAA9C,EAAkD;AAChD,cAAIgB,SAAS,GAAGgH,KAAK,CAACjI,UAAN,CAAiBC,CAAjB,CAAhB;;AAEA,cAAIgB,SAAS,CAACiB,SAAd,EAAyB;AACvB,gBAAImG,cAAJ,EAAoB;AAClB;AACA,qBAAO,IAAP;AACD,aAHD,MAGO;AACL;AACAA,cAAAA,cAAc,GAAG,IAAjB;AACA;AACD;AACF;;AAED,cAAIpJ,YAAY,GAAGgC,SAAS,CAACE,IAA7B;;AAEA,iBAAOlC,YAAY,KAAKJ,KAAjB,IAA0BI,YAAY,IAAI,IAAjD,EAAuD;AACrDA,YAAAA,YAAY,GAAGA,YAAY,CAACC,KAA5B;AACD;;AAED,cAAID,YAAY,KAAKJ,KAArB,EAA4B;AAC1B;AACA;AACA,gBAAI,CAACyJ,gBAAgB,CAAC3J,wBAAD,EAA2BsC,SAAS,CAACf,UAArC,CAArB,EAAuE;AACrE,qBAAO,IAAP;AACD;AACF;AACF;;AAED,eAAO,KAAP;AACD;;AAED,aAAO6D,aAAa,CAACnG,GAAd,CAAkB,UAAUqK,KAAV,EAAiB;AACxC,eAAO;AACLtK,UAAAA,EAAE,EAAEsK,KAAK,CAAC1I,IAAN,CAAW,CAAX,CADC;AAEL2E,UAAAA,kBAAkB,EAAEkE,mBAAmB,CAACH,KAAD;AAFlC,SAAP;AAID,OALM,CAAP;AAMD;AACD;;;;;;;;;AASA,aAASxG,aAAT,CAAuBlN,IAAvB,EAA6B;AAC3B,UAAIA,IAAI,CAACW,MAAL,CAAYV,IAAZ,KAAqB,kBAArB,IAA2CD,IAAI,CAACW,MAAL,CAAYL,MAAZ,KAAuBN,IAAlE,IAA0EA,IAAI,CAACW,MAAL,CAAYP,QAAZ,CAAqBF,IAArB,KAA8B,SAAxG,IAAqH,CAACF,IAAI,CAACW,MAAL,CAAYR,QAAlI,IAA8I,EAAEH,IAAI,CAACW,MAAL,CAAYA,MAAZ,IAAsB,IAAtB,IAA8BX,IAAI,CAACW,MAAL,CAAYA,MAAZ,CAAmBV,IAAnB,KAA4B,gBAA1D,IAA8ED,IAAI,CAACW,MAAL,CAAYA,MAAZ,CAAmBgH,MAAnB,KAA8B3H,IAAI,CAACW,MAAnH,CAAlJ,EAA8Q;AAC5Q,eAAOuM,aAAa,CAAClN,IAAI,CAACW,MAAN,CAApB;AACD,OAFD,MAEO;AACL,eAAOX,IAAP;AACD;AACF;AACD;;;;;;;;;AASA,aAASoN,sBAAT,CAAgCpN,IAAhC,EAAsC;AACpC,UAAIA,IAAI,CAACC,IAAL,KAAc,YAAlB,EAAgC;AAC9B,eAAOD,IAAI,CAACE,IAAZ;AACD,OAFD,MAEO,IAAIF,IAAI,CAACC,IAAL,KAAc,kBAAd,IAAoC,CAACD,IAAI,CAACG,QAA9C,EAAwD;AAC7D,YAAIG,MAAM,GAAG8M,sBAAsB,CAACpN,IAAI,CAACM,MAAN,CAAnC;AACA,YAAIF,QAAQ,GAAGgN,sBAAsB,CAACpN,IAAI,CAACI,QAAN,CAArC;AACA,eAAOE,MAAM,GAAG,GAAT,GAAeF,QAAtB;AACD,OAJM,MAIA;AACL,cAAM,IAAI2R,KAAJ,CAAU,4BAA4B/R,IAAI,CAACC,IAA3C,CAAN;AACD;AACF;;AAED,aAAS+J,4BAAT,CAAsChK,IAAtC,EAA4C2I,OAA5C,EAAqD;AACnD,UAAI3I,IAAI,CAACC,IAAL,KAAc,kBAAd,IAAoCD,IAAI,CAACM,MAAL,CAAYL,IAAZ,KAAqB,YAAzD,IAAyED,IAAI,CAACM,MAAL,CAAYJ,IAAZ,KAAqB,OAA9F,IAAyGF,IAAI,CAACI,QAAL,CAAcH,IAAd,KAAuB,YAAhI,IAAgJ,CAACD,IAAI,CAACG,QAA1J,EAAoK;AAClK,eAAOH,IAAI,CAACI,QAAZ;AACD;;AAED,aAAOJ,IAAP;AACD,KA56Da,CA46DZ;AACF;AACA;AACA;AACA;;;AAGA,aAAS4J,4BAAT,CAAsCoK,UAAtC,EAAkDrL,OAAlD,EAA2D;AACzD,UAAI3I,IAAI,GAAGgK,4BAA4B,CAACgK,UAAD,CAAvC;;AAEA,UAAIhU,IAAI,CAACC,IAAL,KAAc,YAAlB,EAAgC;AAC9B,eAAO,IAAP;AACD;;AAED,cAAQD,IAAI,CAACE,IAAb;AACE,aAAK,WAAL;AACA,aAAK,iBAAL;AACA,aAAK,aAAL;AACA,aAAK,SAAL;AACE;AACA,iBAAO,CAAP;;AAEF,aAAK,qBAAL;AACE;AACA,iBAAO,CAAP;;AAEF;AACE,cAAIF,IAAI,KAAKgU,UAAT,IAAuBrL,OAAvB,IAAkCA,OAAO,CAACD,eAA9C,EAA+D;AAC7D;AACA;AACA,gBAAIxI,IAAJ;;AAEA,gBAAI;AACFA,cAAAA,IAAI,GAAGkN,sBAAsB,CAACpN,IAAD,CAA7B;AACD,aAFD,CAEE,OAAO8O,KAAP,EAAc;AACd,kBAAI,wBAAwBhP,IAAxB,CAA6BgP,KAAK,CAACzH,OAAnC,CAAJ,EAAiD;AAC/C,uBAAO,CAAP;AACD,eAFD,MAEO;AACL,sBAAMyH,KAAN;AACD;AACF;;AAED,mBAAOnG,OAAO,CAACD,eAAR,CAAwB5I,IAAxB,CAA6BI,IAA7B,IAAqC,CAArC,GAAyC,CAAC,CAAjD;AACD,WAhBD,MAgBO;AACL,mBAAO,CAAC,CAAR;AACD;;AA/BL;AAkCD;AACD;;;;;;;;;;;;AAYA,aAASiL,2BAAT,CAAqC0E,KAArC,EAA4CoE,MAA5C,EAAoD;AAClD,UAAIC,KAAK,GAAG,CAACrE,KAAD,CAAZ;AACA,UAAIsE,IAAI,GAAG,IAAX;;AAEA,aAAOD,KAAK,CAAC1Q,MAAb,EAAqB;AACnB2Q,QAAAA,IAAI,GAAGD,KAAK,CAACE,KAAN,EAAP;;AAEA,YAAIC,gBAAgB,CAACF,IAAD,EAAOF,MAAP,CAApB,EAAoC;AAClC,iBAAOE,IAAP;AACD;;AAED,YAAI,CAACJ,gBAAgB,CAACI,IAAD,EAAOF,MAAP,CAArB,EAAqC;AACnC;AACD;;AAED,aAAK,IAAIK,GAAG,GAAG,CAAV,EAAaC,eAAe,GAAGC,MAAM,CAACC,OAAP,CAAeN,IAAf,CAApC,EAA0DG,GAAG,GAAGC,eAAe,CAAC/Q,MAAhF,EAAwF8Q,GAAG,EAA3F,EAA+F;AAC7F,cAAII,kBAAkB,GAAGH,eAAe,CAACD,GAAD,CAAxC;AAAA,cACIpM,GAAG,GAAGwM,kBAAkB,CAAC,CAAD,CAD5B;AAAA,cAEIxR,KAAK,GAAGwR,kBAAkB,CAAC,CAAD,CAF9B;;AAIA,cAAIxM,GAAG,KAAK,QAAZ,EAAsB;AACpB;AACD;;AAED,cAAIyM,UAAU,CAACzR,KAAD,CAAd,EAAuB;AACrBA,YAAAA,KAAK,CAACvC,MAAN,GAAewT,IAAf;AACAD,YAAAA,KAAK,CAAC/S,IAAN,CAAW+B,KAAX;AACD,WAHD,MAGO,IAAI4H,KAAK,CAACC,OAAN,CAAc7H,KAAd,CAAJ,EAA0B;AAC/BA,YAAAA,KAAK,CAACoK,OAAN,CAAc,UAAUsH,GAAV,EAAe;AAC3B,kBAAID,UAAU,CAACC,GAAD,CAAd,EAAqB;AACnBA,gBAAAA,GAAG,CAACjU,MAAJ,GAAawT,IAAb;AACAD,gBAAAA,KAAK,CAAC/S,IAAN,CAAWyT,GAAX;AACD;AACF,aALD;AAMD;AACF;AACF;;AAED,aAAO,IAAP;AACD;;AAED,aAASjE,WAAT,CAAqBkE,GAArB,EAA0B;AACxB,UAAIhV,CAAC,GAAG,EAAR;;AAEA,WAAK,IAAI6L,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmJ,GAAG,CAACrR,MAAxB,EAAgCkI,CAAC,EAAjC,EAAqC;AACnC7L,QAAAA,CAAC,IAAIgV,GAAG,CAACnJ,CAAD,CAAR;;AAEA,YAAIA,CAAC,KAAK,CAAN,IAAWmJ,GAAG,CAACrR,MAAJ,KAAe,CAA9B,EAAiC;AAC/B3D,UAAAA,CAAC,IAAI,OAAL;AACD,SAFD,MAEO,IAAI6L,CAAC,KAAKmJ,GAAG,CAACrR,MAAJ,GAAa,CAAnB,IAAwBqR,GAAG,CAACrR,MAAJ,GAAa,CAAzC,EAA4C;AACjD3D,UAAAA,CAAC,IAAI,QAAL;AACD,SAFM,MAEA,IAAI6L,CAAC,GAAGmJ,GAAG,CAACrR,MAAJ,GAAa,CAArB,EAAwB;AAC7B3D,UAAAA,CAAC,IAAI,IAAL;AACD;AACF;;AAED,aAAOA,CAAP;AACD;;AAED,aAAS8U,UAAT,CAAoBC,GAApB,EAAyB;AACvB,aAAO,OAAOA,GAAP,KAAe,QAAf,IAA2BA,GAAG,KAAK,IAAnC,IAA2C,CAAC9J,KAAK,CAACC,OAAN,CAAc6J,GAAd,CAA5C,IAAkE,OAAOA,GAAG,CAAC3U,IAAX,KAAoB,QAA7F;AACD;;AAED,aAASoU,gBAAT,CAA0BS,CAA1B,EAA6BC,CAA7B,EAAgC;AAC9B,aAAOD,CAAC,CAAC7U,IAAF,KAAW,YAAX,IAA2B6U,CAAC,CAAC5U,IAAF,KAAW6U,CAAC,CAAC7U,IAAxC,IAAgD4U,CAAC,CAACE,KAAF,CAAQ,CAAR,MAAeD,CAAC,CAACC,KAAF,CAAQ,CAAR,CAA/D,IAA6EF,CAAC,CAACE,KAAF,CAAQ,CAAR,MAAeD,CAAC,CAACC,KAAF,CAAQ,CAAR,CAAnG;AACD;;AAED,aAASjB,gBAAT,CAA0Be,CAA1B,EAA6BC,CAA7B,EAAgC;AAC9B,aAAOD,CAAC,CAACE,KAAF,CAAQ,CAAR,KAAcD,CAAC,CAACC,KAAF,CAAQ,CAAR,CAAd,IAA4BF,CAAC,CAACE,KAAF,CAAQ,CAAR,KAAcD,CAAC,CAACC,KAAF,CAAQ,CAAR,CAAjD;AACD;;AAED,QAAIC,KAAK,GAAG;AACV,wBAAkBrU,WADR;AAEV,yBAAmBwH;AAFT,KAAZ;AAKA,QAAI8M,GAAG,GAAGV,MAAM,CAACW,MAAP,CAAc;AACvBF,MAAAA,KAAK,EAAEA;AADgB,KAAd,CAAV;AAIA,QAAIG,sBAAsB,GAAGF,GAA7B;AAEAG,IAAAA,MAAM,CAACC,OAAP,GAAiBF,sBAAjB;AACG,GA5jED;AA6jED","sourcesContent":["/** @license React v2.3.0\n * eslint-plugin-react-hooks.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\n/* eslint-disable no-for-of-loops/no-for-of-loops */\n\n/**\n * Catch all identifiers that begin with \"use\" followed by an uppercase Latin\n * character to exclude identifiers like \"user\".\n */\n\nfunction isHookName(s) {\n  return /^use[A-Z0-9].*$/.test(s);\n}\n/**\n * We consider hooks to be a hook name identifier or a member expression\n * containing a hook name.\n */\n\n\nfunction isHook(node) {\n  if (node.type === 'Identifier') {\n    return isHookName(node.name);\n  } else if (node.type === 'MemberExpression' && !node.computed && isHook(node.property)) {\n    // Only consider React.useFoo() to be namespace hooks for now to avoid false positives.\n    // We can expand this check later.\n    var obj = node.object;\n    return obj.type === 'Identifier' && obj.name === 'React';\n  } else {\n    return false;\n  }\n}\n/**\n * Checks if the node is a React component name. React component names must\n * always start with a non-lowercase letter. So `MyComponent` or `_MyComponent`\n * are valid component names for instance.\n */\n\n\nfunction isComponentName(node) {\n  if (node.type === 'Identifier') {\n    return !/^[a-z]/.test(node.name);\n  } else {\n    return false;\n  }\n}\n\nfunction isInsideComponentOrHook(node) {\n  while (node) {\n    var functionName = getFunctionName(node);\n\n    if (functionName) {\n      if (isComponentName(functionName) || isHook(functionName)) {\n        return true;\n      }\n    }\n\n    node = node.parent;\n  }\n\n  return false;\n}\n\nvar RuleOfHooks = {\n  create: function (context) {\n    var codePathReactHooksMapStack = [];\n    var codePathSegmentStack = [];\n    return {\n      // Maintain code segment path stack as we traverse.\n      onCodePathSegmentStart: function (segment) {\n        return codePathSegmentStack.push(segment);\n      },\n      onCodePathSegmentEnd: function () {\n        return codePathSegmentStack.pop();\n      },\n      // Maintain code path stack as we traverse.\n      onCodePathStart: function () {\n        return codePathReactHooksMapStack.push(new Map());\n      },\n      // Process our code path.\n      //\n      // Everything is ok if all React Hooks are both reachable from the initial\n      // segment and reachable from every final segment.\n      onCodePathEnd: function (codePath, codePathNode) {\n        var reactHooksMap = codePathReactHooksMapStack.pop();\n\n        if (reactHooksMap.size === 0) {\n          return;\n        } // All of the segments which are cyclic are recorded in this set.\n\n\n        var cyclic = new Set();\n        /**\n         * Count the number of code paths from the start of the function to this\n         * segment. For example:\n         *\n         * ```js\n         * function MyComponent() {\n         *   if (condition) {\n         *     // Segment 1\n         *   } else {\n         *     // Segment 2\n         *   }\n         *   // Segment 3\n         * }\n         * ```\n         *\n         * Segments 1 and 2 have one path to the beginning of `MyComponent` and\n         * segment 3 has two paths to the beginning of `MyComponent` since we\n         * could have either taken the path of segment 1 or segment 2.\n         *\n         * Populates `cyclic` with cyclic segments.\n         */\n\n        function countPathsFromStart(segment) {\n          var cache = countPathsFromStart.cache;\n          var paths = cache.get(segment.id); // If `paths` is null then we've found a cycle! Add it to `cyclic` and\n          // any other segments which are a part of this cycle.\n\n          if (paths === null) {\n            if (cyclic.has(segment.id)) {\n              return 0;\n            } else {\n              cyclic.add(segment.id);\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = segment.prevSegments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var prevSegment = _step.value;\n                  countPathsFromStart(prevSegment);\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n\n              return 0;\n            }\n          } // We have a cached `paths`. Return it.\n\n\n          if (paths !== undefined) {\n            return paths;\n          } // Compute `paths` and cache it. Guarding against cycles.\n\n\n          cache.set(segment.id, null);\n\n          if (codePath.thrownSegments.includes(segment)) {\n            paths = 0;\n          } else if (segment.prevSegments.length === 0) {\n            paths = 1;\n          } else {\n            paths = 0;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = segment.prevSegments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var _prevSegment = _step2.value;\n                paths += countPathsFromStart(_prevSegment);\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          } // If our segment is reachable then there should be at least one path\n          // to it from the start of our code path.\n\n\n          if (segment.reachable && paths === 0) {\n            cache.delete(segment.id);\n          } else {\n            cache.set(segment.id, paths);\n          }\n\n          return paths;\n        }\n        /**\n         * Count the number of code paths from this segment to the end of the\n         * function. For example:\n         *\n         * ```js\n         * function MyComponent() {\n         *   // Segment 1\n         *   if (condition) {\n         *     // Segment 2\n         *   } else {\n         *     // Segment 3\n         *   }\n         * }\n         * ```\n         *\n         * Segments 2 and 3 have one path to the end of `MyComponent` and\n         * segment 1 has two paths to the end of `MyComponent` since we could\n         * either take the path of segment 1 or segment 2.\n         *\n         * Populates `cyclic` with cyclic segments.\n         */\n\n\n        function countPathsToEnd(segment) {\n          var cache = countPathsToEnd.cache;\n          var paths = cache.get(segment.id); // If `paths` is null then we've found a cycle! Add it to `cyclic` and\n          // any other segments which are a part of this cycle.\n\n          if (paths === null) {\n            if (cyclic.has(segment.id)) {\n              return 0;\n            } else {\n              cyclic.add(segment.id);\n              var _iteratorNormalCompletion3 = true;\n              var _didIteratorError3 = false;\n              var _iteratorError3 = undefined;\n\n              try {\n                for (var _iterator3 = segment.nextSegments[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                  var nextSegment = _step3.value;\n                  countPathsToEnd(nextSegment);\n                }\n              } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                    _iterator3.return();\n                  }\n                } finally {\n                  if (_didIteratorError3) {\n                    throw _iteratorError3;\n                  }\n                }\n              }\n\n              return 0;\n            }\n          } // We have a cached `paths`. Return it.\n\n\n          if (paths !== undefined) {\n            return paths;\n          } // Compute `paths` and cache it. Guarding against cycles.\n\n\n          cache.set(segment.id, null);\n\n          if (codePath.thrownSegments.includes(segment)) {\n            paths = 0;\n          } else if (segment.nextSegments.length === 0) {\n            paths = 1;\n          } else {\n            paths = 0;\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n              for (var _iterator4 = segment.nextSegments[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                var _nextSegment = _step4.value;\n                paths += countPathsToEnd(_nextSegment);\n              }\n            } catch (err) {\n              _didIteratorError4 = true;\n              _iteratorError4 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                  _iterator4.return();\n                }\n              } finally {\n                if (_didIteratorError4) {\n                  throw _iteratorError4;\n                }\n              }\n            }\n          }\n\n          cache.set(segment.id, paths);\n          return paths;\n        }\n        /**\n         * Gets the shortest path length to the start of a code path.\n         * For example:\n         *\n         * ```js\n         * function MyComponent() {\n         *   if (condition) {\n         *     // Segment 1\n         *   }\n         *   // Segment 2\n         * }\n         * ```\n         *\n         * There is only one path from segment 1 to the code path start. Its\n         * length is one so that is the shortest path.\n         *\n         * There are two paths from segment 2 to the code path start. One\n         * through segment 1 with a length of two and another directly to the\n         * start with a length of one. The shortest path has a length of one\n         * so we would return that.\n         */\n\n\n        function shortestPathLengthToStart(segment) {\n          var cache = shortestPathLengthToStart.cache;\n          var length = cache.get(segment.id); // If `length` is null then we found a cycle! Return infinity since\n          // the shortest path is definitely not the one where we looped.\n\n          if (length === null) {\n            return Infinity;\n          } // We have a cached `length`. Return it.\n\n\n          if (length !== undefined) {\n            return length;\n          } // Compute `length` and cache it. Guarding against cycles.\n\n\n          cache.set(segment.id, null);\n\n          if (segment.prevSegments.length === 0) {\n            length = 1;\n          } else {\n            length = Infinity;\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n              for (var _iterator5 = segment.prevSegments[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                var prevSegment = _step5.value;\n                var prevLength = shortestPathLengthToStart(prevSegment);\n\n                if (prevLength < length) {\n                  length = prevLength;\n                }\n              }\n            } catch (err) {\n              _didIteratorError5 = true;\n              _iteratorError5 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                  _iterator5.return();\n                }\n              } finally {\n                if (_didIteratorError5) {\n                  throw _iteratorError5;\n                }\n              }\n            }\n\n            length += 1;\n          }\n\n          cache.set(segment.id, length);\n          return length;\n        }\n\n        countPathsFromStart.cache = new Map();\n        countPathsToEnd.cache = new Map();\n        shortestPathLengthToStart.cache = new Map(); // Count all code paths to the end of our component/hook. Also primes\n        // the `countPathsToEnd` cache.\n\n        var allPathsFromStartToEnd = countPathsToEnd(codePath.initialSegment); // Gets the function name for our code path. If the function name is\n        // `undefined` then we know either that we have an anonymous function\n        // expression or our code path is not in a function. In both cases we\n        // will want to error since neither are React function components or\n        // hook functions.\n\n        var codePathFunctionName = getFunctionName(codePathNode); // This is a valid code path for React hooks if we are directly in a React\n        // function component or we are in a hook function.\n\n        var isSomewhereInsideComponentOrHook = isInsideComponentOrHook(codePathNode);\n        var isDirectlyInsideComponentOrHook = codePathFunctionName ? isComponentName(codePathFunctionName) || isHook(codePathFunctionName) : false; // Compute the earliest finalizer level using information from the\n        // cache. We expect all reachable final segments to have a cache entry\n        // after calling `visitSegment()`.\n\n        var shortestFinalPathLength = Infinity;\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = codePath.finalSegments[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var finalSegment = _step6.value;\n\n            if (!finalSegment.reachable) {\n              continue;\n            }\n\n            var length = shortestPathLengthToStart(finalSegment);\n\n            if (length < shortestFinalPathLength) {\n              shortestFinalPathLength = length;\n            }\n          } // Make sure all React Hooks pass our lint invariants. Log warnings\n          // if not.\n\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = reactHooksMap[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var _step7$value = _step7.value,\n                segment = _step7$value[0],\n                reactHooks = _step7$value[1];\n\n            // NOTE: We could report here that the hook is not reachable, but\n            // that would be redundant with more general \"no unreachable\"\n            // lint rules.\n            if (!segment.reachable) {\n              continue;\n            } // If there are any final segments with a shorter path to start then\n            // we possibly have an early return.\n            //\n            // If our segment is a final segment itself then siblings could\n            // possibly be early returns.\n\n\n            var possiblyHasEarlyReturn = segment.nextSegments.length === 0 ? shortestFinalPathLength <= shortestPathLengthToStart(segment) : shortestFinalPathLength < shortestPathLengthToStart(segment); // Count all the paths from the start of our code path to the end of\n            // our code path that go _through_ this segment. The critical piece\n            // of this is _through_. If we just call `countPathsToEnd(segment)`\n            // then we neglect that we may have gone through multiple paths to get\n            // to this point! Consider:\n            //\n            // ```js\n            // function MyComponent() {\n            //   if (a) {\n            //     // Segment 1\n            //   } else {\n            //     // Segment 2\n            //   }\n            //   // Segment 3\n            //   if (b) {\n            //     // Segment 4\n            //   } else {\n            //     // Segment 5\n            //   }\n            // }\n            // ```\n            //\n            // In this component we have four code paths:\n            //\n            // 1. `a = true; b = true`\n            // 2. `a = true; b = false`\n            // 3. `a = false; b = true`\n            // 4. `a = false; b = false`\n            //\n            // From segment 3 there are two code paths to the end through segment\n            // 4 and segment 5. However, we took two paths to get here through\n            // segment 1 and segment 2.\n            //\n            // If we multiply the paths from start (two) by the paths to end (two)\n            // for segment 3 we get four. Which is our desired count.\n\n            var pathsFromStartToEnd = countPathsFromStart(segment) * countPathsToEnd(segment); // Is this hook a part of a cyclic segment?\n\n            var cycled = cyclic.has(segment.id);\n            var _iteratorNormalCompletion8 = true;\n            var _didIteratorError8 = false;\n            var _iteratorError8 = undefined;\n\n            try {\n              for (var _iterator8 = reactHooks[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                var hook = _step8.value;\n\n                // Report an error if a hook may be called more then once.\n                if (cycled) {\n                  context.report({\n                    node: hook,\n                    message: \"React Hook \\\"\" + context.getSource(hook) + \"\\\" may be executed \" + 'more than once. Possibly because it is called in a loop. ' + 'React Hooks must be called in the exact same order in ' + 'every component render.'\n                  });\n                } // If this is not a valid code path for React hooks then we need to\n                // log a warning for every hook in this code path.\n                //\n                // Pick a special message depending on the scope this hook was\n                // called in.\n\n\n                if (isDirectlyInsideComponentOrHook) {\n                  // Report an error if a hook does not reach all finalizing code\n                  // path segments.\n                  //\n                  // Special case when we think there might be an early return.\n                  if (!cycled && pathsFromStartToEnd !== allPathsFromStartToEnd) {\n                    var message = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" is called \" + 'conditionally. React Hooks must be called in the exact ' + 'same order in every component render.' + (possiblyHasEarlyReturn ? ' Did you accidentally call a React Hook after an' + ' early return?' : '');\n                    context.report({\n                      node: hook,\n                      message: message\n                    });\n                  }\n                } else if (codePathNode.parent && (codePathNode.parent.type === 'MethodDefinition' || codePathNode.parent.type === 'ClassProperty') && codePathNode.parent.value === codePathNode) {// Ignore class methods for now because they produce too many\n                  // false positives due to feature flag checks. We're less\n                  // sensitive to them in classes because hooks would produce\n                  // runtime errors in classes anyway, and because a use*()\n                  // call in a class, if it works, is unambiguously *not* a hook.\n                } else if (codePathFunctionName) {\n                  // Custom message if we found an invalid function name.\n                  var _message = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" is called in \" + (\"function \\\"\" + context.getSource(codePathFunctionName) + \"\\\" \") + 'that is neither a React function component nor a custom ' + 'React Hook function.';\n\n                  context.report({\n                    node: hook,\n                    message: _message\n                  });\n                } else if (codePathNode.type === 'Program') {\n                  // These are dangerous if you have inline requires enabled.\n                  var _message2 = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" cannot be called \" + 'at the top level. React Hooks must be called in a ' + 'React function component or a custom React Hook function.';\n\n                  context.report({\n                    node: hook,\n                    message: _message2\n                  });\n                } else {\n                  // Assume in all other cases the user called a hook in some\n                  // random function callback. This should usually be true for\n                  // anonymous function expressions. Hopefully this is clarifying\n                  // enough in the common case that the incorrect message in\n                  // uncommon cases doesn't matter.\n                  if (isSomewhereInsideComponentOrHook) {\n                    var _message3 = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" cannot be called \" + 'inside a callback. React Hooks must be called in a ' + 'React function component or a custom React Hook function.';\n\n                    context.report({\n                      node: hook,\n                      message: _message3\n                    });\n                  }\n                }\n              }\n            } catch (err) {\n              _didIteratorError8 = true;\n              _iteratorError8 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n                  _iterator8.return();\n                }\n              } finally {\n                if (_didIteratorError8) {\n                  throw _iteratorError8;\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      },\n      // Missed opportunity...We could visit all `Identifier`s instead of all\n      // `CallExpression`s and check that _every use_ of a hook name is valid.\n      // But that gets complicated and enters type-system territory, so we're\n      // only being strict about hook calls for now.\n      CallExpression: function (node) {\n        if (isHook(node.callee)) {\n          // Add the hook node to a map keyed by the code path segment. We will\n          // do full code path analysis at the end of our code path.\n          var reactHooksMap = last(codePathReactHooksMapStack);\n          var codePathSegment = last(codePathSegmentStack);\n          var reactHooks = reactHooksMap.get(codePathSegment);\n\n          if (!reactHooks) {\n            reactHooks = [];\n            reactHooksMap.set(codePathSegment, reactHooks);\n          }\n\n          reactHooks.push(node.callee);\n        }\n      }\n    };\n  }\n};\n/**\n * Gets the static name of a function AST node. For function declarations it is\n * easy. For anonymous function expressions it is much harder. If you search for\n * `IsAnonymousFunctionDefinition()` in the ECMAScript spec you'll find places\n * where JS gives anonymous function expressions names. We roughly detect the\n * same AST nodes with some exceptions to better fit our usecase.\n */\n\nfunction getFunctionName(node) {\n  if (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' && node.id) {\n    // function useHook() {}\n    // const whatever = function useHook() {};\n    //\n    // Function declaration or function expression names win over any\n    // assignment statements or other renames.\n    return node.id;\n  } else if (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') {\n    if (node.parent.type === 'VariableDeclarator' && node.parent.init === node) {\n      // const useHook = () => {};\n      return node.parent.id;\n    } else if (node.parent.type === 'AssignmentExpression' && node.parent.right === node && node.parent.operator === '=') {\n      // useHook = () => {};\n      return node.parent.left;\n    } else if (node.parent.type === 'Property' && node.parent.value === node && !node.parent.computed) {\n      // {useHook: () => {}}\n      // {useHook() {}}\n      return node.parent.key; // NOTE: We could also support `ClassProperty` and `MethodDefinition`\n      // here to be pedantic. However, hooks in a class are an anti-pattern. So\n      // we don't allow it to error early.\n      //\n      // class {useHook = () => {}}\n      // class {useHook() {}}\n    } else if (node.parent.type === 'AssignmentPattern' && node.parent.right === node && !node.parent.computed) {\n      // const {useHook = () => {}} = {};\n      // ({useHook = () => {}} = {});\n      //\n      // Kinda clowny, but we'd said we'd follow spec convention for\n      // `IsAnonymousFunctionDefinition()` usage.\n      return node.parent.left;\n    } else {\n      return undefined;\n    }\n  } else {\n    return undefined;\n  }\n}\n/**\n * Convenience function for peeking the last item in a stack.\n */\n\n\nfunction last(array) {\n  return array[array.length - 1];\n}\n\n/* eslint-disable no-for-of-loops/no-for-of-loops */\n\n\nvar ExhaustiveDeps = {\n  meta: {\n    fixable: 'code',\n    schema: [{\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        additionalHooks: {\n          type: 'string'\n        }\n      }\n    }]\n  },\n  create: function (context) {\n    // Parse the `additionalHooks` regex.\n    var additionalHooks = context.options && context.options[0] && context.options[0].additionalHooks ? new RegExp(context.options[0].additionalHooks) : undefined;\n    var options = {\n      additionalHooks: additionalHooks\n    }; // Should be shared between visitors.\n\n    var setStateCallSites = new WeakMap();\n    var stateVariables = new WeakSet();\n    var staticKnownValueCache = new WeakMap();\n    var functionWithoutCapturedValueCache = new WeakMap();\n\n    function memoizeWithWeakMap(fn, map) {\n      return function (arg) {\n        if (map.has(arg)) {\n          // to verify cache hits:\n          // console.log(arg.name)\n          return map.get(arg);\n        }\n\n        var result = fn(arg);\n        map.set(arg, result);\n        return result;\n      };\n    }\n\n    return {\n      FunctionExpression: visitFunctionExpression,\n      ArrowFunctionExpression: visitFunctionExpression\n    };\n    /**\n     * Visitor for both function expressions and arrow function expressions.\n     */\n\n    function visitFunctionExpression(node) {\n      // We only want to lint nodes which are reactive hook callbacks.\n      if (node.type !== 'FunctionExpression' && node.type !== 'ArrowFunctionExpression' || node.parent.type !== 'CallExpression') {\n        return;\n      }\n\n      var callbackIndex = getReactiveHookCallbackIndex(node.parent.callee, options);\n\n      if (node.parent.arguments[callbackIndex] !== node) {\n        return;\n      } // Get the reactive hook node.\n\n\n      var reactiveHook = node.parent.callee;\n      var reactiveHookName = getNodeWithoutReactNamespace(reactiveHook).name;\n      var isEffect = reactiveHookName.endsWith('Effect'); // Get the declared dependencies for this reactive hook. If there is no\n      // second argument then the reactive callback will re-run on every render.\n      // So no need to check for dependency inclusion.\n\n      var depsIndex = callbackIndex + 1;\n      var declaredDependenciesNode = node.parent.arguments[depsIndex];\n\n      if (!declaredDependenciesNode && !isEffect) {\n        // These are only used for optimization.\n        if (reactiveHookName === 'useMemo' || reactiveHookName === 'useCallback') {\n          // TODO: Can this have an autofix?\n          context.report({\n            node: node.parent.callee,\n            message: \"React Hook \" + reactiveHookName + \" does nothing when called with \" + \"only one argument. Did you forget to pass an array of \" + \"dependencies?\"\n          });\n        }\n\n        return;\n      }\n\n      if (isEffect && node.async) {\n        context.report({\n          node: node,\n          message: \"Effect callbacks are synchronous to prevent race conditions. \" + \"Put the async function inside:\\n\\n\" + 'useEffect(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + \"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\" + 'Learn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching'\n        });\n      } // Get the current scope.\n\n\n      var scope = context.getScope(); // Find all our \"pure scopes\". On every re-render of a component these\n      // pure scopes may have changes to the variables declared within. So all\n      // variables used in our reactive hook callback but declared in a pure\n      // scope need to be listed as dependencies of our reactive hook callback.\n      //\n      // According to the rules of React you can't read a mutable value in pure\n      // scope. We can't enforce this in a lint so we trust that all variables\n      // declared outside of pure scope are indeed frozen.\n\n      var pureScopes = new Set();\n      var componentScope = null;\n      {\n        var currentScope = scope.upper;\n\n        while (currentScope) {\n          pureScopes.add(currentScope);\n\n          if (currentScope.type === 'function') {\n            break;\n          }\n\n          currentScope = currentScope.upper;\n        } // If there is no parent function scope then there are no pure scopes.\n        // The ones we've collected so far are incorrect. So don't continue with\n        // the lint.\n\n\n        if (!currentScope) {\n          return;\n        }\n\n        componentScope = currentScope;\n      } // Next we'll define a few helpers that helps us\n      // tell if some values don't have to be declared as deps.\n      // Some are known to be static based on Hook calls.\n      // const [state, setState] = useState() / React.useState()\n      //               ^^^ true for this reference\n      // const [state, dispatch] = useReducer() / React.useReducer()\n      //               ^^^ true for this reference\n      // const ref = useRef()\n      //       ^^^ true for this reference\n      // False for everything else.\n\n      function isStaticKnownHookValue(resolved) {\n        if (!Array.isArray(resolved.defs)) {\n          return false;\n        }\n\n        var def = resolved.defs[0];\n\n        if (def == null) {\n          return false;\n        } // Look for `let stuff = ...`\n\n\n        if (def.node.type !== 'VariableDeclarator') {\n          return false;\n        }\n\n        var init = def.node.init;\n\n        if (init == null) {\n          return false;\n        } // Detect primitive constants\n        // const foo = 42\n\n\n        var declaration = def.node.parent;\n\n        if (declaration == null) {\n          // This might happen if variable is declared after the callback.\n          // In that case ESLint won't set up .parent refs.\n          // So we'll set them up manually.\n          fastFindReferenceWithParent(componentScope.block, def.node.id);\n          declaration = def.node.parent;\n\n          if (declaration == null) {\n            return false;\n          }\n        }\n\n        if (declaration.kind === 'const' && init.type === 'Literal' && (typeof init.value === 'string' || typeof init.value === 'number' || init.value === null)) {\n          // Definitely static\n          return true;\n        } // Detect known Hook calls\n        // const [_, setState] = useState()\n\n\n        if (init.type !== 'CallExpression') {\n          return false;\n        }\n\n        var callee = init.callee; // Step into `= React.something` initializer.\n\n        if (callee.type === 'MemberExpression' && callee.object.name === 'React' && callee.property != null && !callee.computed) {\n          callee = callee.property;\n        }\n\n        if (callee.type !== 'Identifier') {\n          return false;\n        }\n\n        var id = def.node.id;\n        var _callee = callee,\n            name = _callee.name;\n\n        if (name === 'useRef' && id.type === 'Identifier') {\n          // useRef() return value is static.\n          return true;\n        } else if (name === 'useState' || name === 'useReducer') {\n          // Only consider second value in initializing tuple static.\n          if (id.type === 'ArrayPattern' && id.elements.length === 2 && Array.isArray(resolved.identifiers)) {\n            // Is second tuple value the same reference we're checking?\n            if (id.elements[1] === resolved.identifiers[0]) {\n              if (name === 'useState') {\n                var references = resolved.references;\n\n                for (var i = 0; i < references.length; i++) {\n                  setStateCallSites.set(references[i].identifier, id.elements[0]);\n                }\n              } // Setter is static.\n\n\n              return true;\n            } else if (id.elements[0] === resolved.identifiers[0]) {\n              if (name === 'useState') {\n                var _references = resolved.references;\n\n                for (var _i = 0; _i < _references.length; _i++) {\n                  stateVariables.add(_references[_i].identifier);\n                }\n              } // State variable itself is dynamic.\n\n\n              return false;\n            }\n          }\n        } // By default assume it's dynamic.\n\n\n        return false;\n      } // Some are just functions that don't reference anything dynamic.\n\n\n      function isFunctionWithoutCapturedValues(resolved) {\n        if (!Array.isArray(resolved.defs)) {\n          return false;\n        }\n\n        var def = resolved.defs[0];\n\n        if (def == null) {\n          return false;\n        }\n\n        if (def.node == null || def.node.id == null) {\n          return false;\n        } // Search the direct component subscopes for\n        // top-level function definitions matching this reference.\n\n\n        var fnNode = def.node;\n        var childScopes = componentScope.childScopes;\n        var fnScope = null;\n        var i;\n\n        for (i = 0; i < childScopes.length; i++) {\n          var childScope = childScopes[i];\n          var childScopeBlock = childScope.block;\n\n          if ( // function handleChange() {}\n          fnNode.type === 'FunctionDeclaration' && childScopeBlock === fnNode || // const handleChange = () => {}\n          // const handleChange = function() {}\n          fnNode.type === 'VariableDeclarator' && childScopeBlock.parent === fnNode) {\n            // Found it!\n            fnScope = childScope;\n            break;\n          }\n        }\n\n        if (fnScope == null) {\n          return false;\n        } // Does this function capture any values\n        // that are in pure scopes (aka render)?\n\n\n        for (i = 0; i < fnScope.through.length; i++) {\n          var ref = fnScope.through[i];\n\n          if (ref.resolved == null) {\n            continue;\n          }\n\n          if (pureScopes.has(ref.resolved.scope) && // Static values are fine though,\n          // although we won't check functions deeper.\n          !memoizedIsStaticKnownHookValue(ref.resolved)) {\n            return false;\n          }\n        } // If we got here, this function doesn't capture anything\n        // from render--or everything it captures is known static.\n\n\n        return true;\n      } // Remember such values. Avoid re-running extra checks on them.\n\n\n      var memoizedIsStaticKnownHookValue = memoizeWithWeakMap(isStaticKnownHookValue, staticKnownValueCache);\n      var memoizedIsFunctionWithoutCapturedValues = memoizeWithWeakMap(isFunctionWithoutCapturedValues, functionWithoutCapturedValueCache); // These are usually mistaken. Collect them.\n\n      var currentRefsInEffectCleanup = new Map(); // Is this reference inside a cleanup function for this effect node?\n      // We can check by traversing scopes upwards  from the reference, and checking\n      // if the last \"return () => \" we encounter is located directly inside the effect.\n\n      function isInsideEffectCleanup(reference) {\n        var curScope = reference.from;\n        var isInReturnedFunction = false;\n\n        while (curScope.block !== node) {\n          if (curScope.type === 'function') {\n            isInReturnedFunction = curScope.block.parent != null && curScope.block.parent.type === 'ReturnStatement';\n          }\n\n          curScope = curScope.upper;\n        }\n\n        return isInReturnedFunction;\n      } // Get dependencies from all our resolved references in pure scopes.\n      // Key is dependency string, value is whether it's static.\n\n\n      var dependencies = new Map();\n      gatherDependenciesRecursively(scope);\n\n      function gatherDependenciesRecursively(currentScope) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = currentScope.references[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var reference = _step.value;\n\n            // If this reference is not resolved or it is not declared in a pure\n            // scope then we don't care about this reference.\n            if (!reference.resolved) {\n              continue;\n            }\n\n            if (!pureScopes.has(reference.resolved.scope)) {\n              continue;\n            } // Narrow the scope of a dependency if it is, say, a member expression.\n            // Then normalize the narrowed dependency.\n\n\n            var referenceNode = fastFindReferenceWithParent(node, reference.identifier);\n            var dependencyNode = getDependency(referenceNode);\n            var dependency = toPropertyAccessString(dependencyNode); // Accessing ref.current inside effect cleanup is bad.\n\n            if ( // We're in an effect...\n            isEffect && // ... and this look like accessing .current...\n            dependencyNode.type === 'Identifier' && dependencyNode.parent.type === 'MemberExpression' && !dependencyNode.parent.computed && dependencyNode.parent.property.type === 'Identifier' && dependencyNode.parent.property.name === 'current' && // ...in a cleanup function or below...\n            isInsideEffectCleanup(reference)) {\n              currentRefsInEffectCleanup.set(dependency, {\n                reference: reference,\n                dependencyNode: dependencyNode\n              });\n            }\n\n            var def = reference.resolved.defs[0];\n\n            if (def == null) {\n              continue;\n            } // Ignore references to the function itself as it's not defined yet.\n\n\n            if (def.node != null && def.node.init === node.parent) {\n              continue;\n            } // Ignore Flow type parameters\n\n\n            if (def.type === 'TypeParameter') {\n              continue;\n            } // Add the dependency to a map so we can make sure it is referenced\n            // again in our dependencies array. Remember whether it's static.\n\n\n            if (!dependencies.has(dependency)) {\n              var resolved = reference.resolved;\n              var isStatic = memoizedIsStaticKnownHookValue(resolved) || memoizedIsFunctionWithoutCapturedValues(resolved);\n              dependencies.set(dependency, {\n                isStatic: isStatic,\n                references: [reference]\n              });\n            } else {\n              dependencies.get(dependency).references.push(reference);\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = currentScope.childScopes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var childScope = _step2.value;\n            gatherDependenciesRecursively(childScope);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } // Warn about accessing .current in cleanup effects.\n\n\n      currentRefsInEffectCleanup.forEach(function (_ref, dependency) {\n        var reference = _ref.reference,\n            dependencyNode = _ref.dependencyNode;\n        var references = reference.resolved.references; // Is React managing this ref or us?\n        // Let's see if we can find a .current assignment.\n\n        var foundCurrentAssignment = false;\n\n        for (var i = 0; i < references.length; i++) {\n          var identifier = references[i].identifier;\n          var parent = identifier.parent;\n\n          if (parent != null && // ref.current\n          parent.type === 'MemberExpression' && !parent.computed && parent.property.type === 'Identifier' && parent.property.name === 'current' && // ref.current = <something>\n          parent.parent.type === 'AssignmentExpression' && parent.parent.left === parent) {\n            foundCurrentAssignment = true;\n            break;\n          }\n        } // We only want to warn about React-managed refs.\n\n\n        if (foundCurrentAssignment) {\n          return;\n        }\n\n        context.report({\n          node: dependencyNode.parent.property,\n          message: \"The ref value '\" + dependency + \".current' will likely have \" + \"changed by the time this effect cleanup function runs. If \" + \"this ref points to a node rendered by React, copy \" + (\"'\" + dependency + \".current' to a variable inside the effect, and \") + \"use that variable in the cleanup function.\"\n        });\n      }); // Warn about assigning to variables in the outer scope.\n      // Those are usually bugs.\n\n      var staleAssignments = new Set();\n\n      function reportStaleAssignment(writeExpr, key) {\n        if (staleAssignments.has(key)) {\n          return;\n        }\n\n        staleAssignments.add(key);\n        context.report({\n          node: writeExpr,\n          message: \"Assignments to the '\" + key + \"' variable from inside React Hook \" + (context.getSource(reactiveHook) + \" will be lost after each \") + \"render. To preserve the value over time, store it in a useRef \" + \"Hook and keep the mutable value in the '.current' property. \" + \"Otherwise, you can move this variable directly inside \" + (context.getSource(reactiveHook) + \".\")\n        });\n      } // Remember which deps are optional and report bad usage first.\n\n\n      var optionalDependencies = new Set();\n      dependencies.forEach(function (_ref2, key) {\n        var isStatic = _ref2.isStatic,\n            references = _ref2.references;\n\n        if (isStatic) {\n          optionalDependencies.add(key);\n        }\n\n        references.forEach(function (reference) {\n          if (reference.writeExpr) {\n            reportStaleAssignment(reference.writeExpr, key);\n          }\n        });\n      });\n\n      if (staleAssignments.size > 0) {\n        // The intent isn't clear so we'll wait until you fix those first.\n        return;\n      }\n\n      if (!declaredDependenciesNode) {\n        // Check if there are any top-level setState() calls.\n        // Those tend to lead to infinite loops.\n        var setStateInsideEffectWithoutDeps = null;\n        dependencies.forEach(function (_ref3, key) {\n          var isStatic = _ref3.isStatic,\n              references = _ref3.references;\n\n          if (setStateInsideEffectWithoutDeps) {\n            return;\n          }\n\n          references.forEach(function (reference) {\n            if (setStateInsideEffectWithoutDeps) {\n              return;\n            }\n\n            var id = reference.identifier;\n            var isSetState = setStateCallSites.has(id);\n\n            if (!isSetState) {\n              return;\n            }\n\n            var fnScope = reference.from;\n\n            while (fnScope.type !== 'function') {\n              fnScope = fnScope.upper;\n            }\n\n            var isDirectlyInsideEffect = fnScope.block === node;\n\n            if (isDirectlyInsideEffect) {\n              // TODO: we could potentially ignore early returns.\n              setStateInsideEffectWithoutDeps = key;\n            }\n          });\n        });\n\n        if (setStateInsideEffectWithoutDeps) {\n          var _collectRecommendatio = collectRecommendations({\n            dependencies: dependencies,\n            declaredDependencies: [],\n            optionalDependencies: optionalDependencies,\n            externalDependencies: new Set(),\n            isEffect: true\n          }),\n              _suggestedDependencies = _collectRecommendatio.suggestedDependencies;\n\n          context.report({\n            node: node.parent.callee,\n            message: \"React Hook \" + reactiveHookName + \" contains a call to '\" + setStateInsideEffectWithoutDeps + \"'. \" + \"Without a list of dependencies, this can lead to an infinite chain of updates. \" + \"To fix this, pass [\" + _suggestedDependencies.join(', ') + (\"] as a second argument to the \" + reactiveHookName + \" Hook.\"),\n            fix: function (fixer) {\n              return fixer.insertTextAfter(node, \", [\" + _suggestedDependencies.join(', ') + \"]\");\n            }\n          });\n        }\n\n        return;\n      }\n\n      var declaredDependencies = [];\n      var externalDependencies = new Set();\n\n      if (declaredDependenciesNode.type !== 'ArrayExpression') {\n        // If the declared dependencies are not an array expression then we\n        // can't verify that the user provided the correct dependencies. Tell\n        // the user this in an error.\n        context.report({\n          node: declaredDependenciesNode,\n          message: \"React Hook \" + context.getSource(reactiveHook) + \" was passed a \" + 'dependency list that is not an array literal. This means we ' + \"can't statically verify whether you've passed the correct \" + 'dependencies.'\n        });\n      } else {\n        declaredDependenciesNode.elements.forEach(function (declaredDependencyNode) {\n          // Skip elided elements.\n          if (declaredDependencyNode === null) {\n            return;\n          } // If we see a spread element then add a special warning.\n\n\n          if (declaredDependencyNode.type === 'SpreadElement') {\n            context.report({\n              node: declaredDependencyNode,\n              message: \"React Hook \" + context.getSource(reactiveHook) + \" has a spread \" + \"element in its dependency array. This means we can't \" + \"statically verify whether you've passed the \" + 'correct dependencies.'\n            });\n            return;\n          } // Try to normalize the declared dependency. If we can't then an error\n          // will be thrown. We will catch that error and report an error.\n\n\n          var declaredDependency;\n\n          try {\n            declaredDependency = toPropertyAccessString(declaredDependencyNode);\n          } catch (error) {\n            if (/Unsupported node type/.test(error.message)) {\n              if (declaredDependencyNode.type === 'Literal') {\n                if (dependencies.has(declaredDependencyNode.value)) {\n                  context.report({\n                    node: declaredDependencyNode,\n                    message: \"The \" + declaredDependencyNode.raw + \" literal is not a valid dependency \" + \"because it never changes. \" + (\"Did you mean to include \" + declaredDependencyNode.value + \" in the array instead?\")\n                  });\n                } else {\n                  context.report({\n                    node: declaredDependencyNode,\n                    message: \"The \" + declaredDependencyNode.raw + \" literal is not a valid dependency \" + 'because it never changes. You can safely remove it.'\n                  });\n                }\n              } else {\n                context.report({\n                  node: declaredDependencyNode,\n                  message: \"React Hook \" + context.getSource(reactiveHook) + \" has a \" + \"complex expression in the dependency array. \" + 'Extract it to a separate variable so it can be statically checked.'\n                });\n              }\n\n              return;\n            } else {\n              throw error;\n            }\n          }\n\n          var maybeID = declaredDependencyNode;\n\n          while (maybeID.type === 'MemberExpression') {\n            maybeID = maybeID.object;\n          }\n\n          var isDeclaredInComponent = !componentScope.through.some(function (ref) {\n            return ref.identifier === maybeID;\n          }); // Add the dependency to our declared dependency map.\n\n          declaredDependencies.push({\n            key: declaredDependency,\n            node: declaredDependencyNode\n          });\n\n          if (!isDeclaredInComponent) {\n            externalDependencies.add(declaredDependency);\n          }\n        });\n      }\n\n      var _collectRecommendatio2 = collectRecommendations({\n        dependencies: dependencies,\n        declaredDependencies: declaredDependencies,\n        optionalDependencies: optionalDependencies,\n        externalDependencies: externalDependencies,\n        isEffect: isEffect\n      }),\n          suggestedDependencies = _collectRecommendatio2.suggestedDependencies,\n          unnecessaryDependencies = _collectRecommendatio2.unnecessaryDependencies,\n          missingDependencies = _collectRecommendatio2.missingDependencies,\n          duplicateDependencies = _collectRecommendatio2.duplicateDependencies;\n\n      var problemCount = duplicateDependencies.size + missingDependencies.size + unnecessaryDependencies.size;\n\n      if (problemCount === 0) {\n        // If nothing else to report, check if some callbacks\n        // are bare and would invalidate on every render.\n        var bareFunctions = scanForDeclaredBareFunctions({\n          declaredDependencies: declaredDependencies,\n          declaredDependenciesNode: declaredDependenciesNode,\n          componentScope: componentScope,\n          scope: scope\n        });\n        bareFunctions.forEach(function (_ref4) {\n          var fn = _ref4.fn,\n              suggestUseCallback = _ref4.suggestUseCallback;\n          var message = \"The '\" + fn.name.name + \"' function makes the dependencies of \" + (reactiveHookName + \" Hook (at line \" + declaredDependenciesNode.loc.start.line + \") \") + \"change on every render.\";\n\n          if (suggestUseCallback) {\n            message += \" To fix this, \" + (\"wrap the '\" + fn.name.name + \"' definition into its own useCallback() Hook.\");\n          } else {\n            message += \" Move it inside the \" + reactiveHookName + \" callback. \" + (\"Alternatively, wrap the '\" + fn.name.name + \"' definition into its own useCallback() Hook.\");\n          } // TODO: What if the function needs to change on every render anyway?\n          // Should we suggest removing effect deps as an appropriate fix too?\n\n\n          context.report({\n            // TODO: Why not report this at the dependency site?\n            node: fn.node,\n            message: message,\n            fix: function (fixer) {\n              // Only handle the simple case: arrow functions.\n              // Wrapping function declarations can mess up hoisting.\n              if (suggestUseCallback && fn.type === 'Variable') {\n                return [// TODO: also add an import?\n                fixer.insertTextBefore(fn.node.init, 'useCallback('), // TODO: ideally we'd gather deps here but it would require\n                // restructuring the rule code. This will cause a new lint\n                // error to appear immediately for useCallback. Note we're\n                // not adding [] because would that changes semantics.\n                fixer.insertTextAfter(fn.node.init, ')')];\n              }\n            }\n          });\n        });\n        return;\n      } // If we're going to report a missing dependency,\n      // we might as well recalculate the list ignoring\n      // the currently specified deps. This can result\n      // in some extra deduplication. We can't do this\n      // for effects though because those have legit\n      // use cases for over-specifying deps.\n\n\n      if (!isEffect && missingDependencies.size > 0) {\n        suggestedDependencies = collectRecommendations({\n          dependencies: dependencies,\n          declaredDependencies: [],\n          // Pretend we don't know\n          optionalDependencies: optionalDependencies,\n          externalDependencies: externalDependencies,\n          isEffect: isEffect\n        }).suggestedDependencies;\n      } // Alphabetize the suggestions, but only if deps were already alphabetized.\n\n\n      function areDeclaredDepsAlphabetized() {\n        if (declaredDependencies.length === 0) {\n          return true;\n        }\n\n        var declaredDepKeys = declaredDependencies.map(function (dep) {\n          return dep.key;\n        });\n        var sortedDeclaredDepKeys = declaredDepKeys.slice().sort();\n        return declaredDepKeys.join(',') === sortedDeclaredDepKeys.join(',');\n      }\n\n      if (areDeclaredDepsAlphabetized()) {\n        suggestedDependencies.sort();\n      }\n\n      function getWarningMessage(deps, singlePrefix, label, fixVerb) {\n        if (deps.size === 0) {\n          return null;\n        }\n\n        return (deps.size > 1 ? '' : singlePrefix + ' ') + label + ' ' + (deps.size > 1 ? 'dependencies' : 'dependency') + ': ' + joinEnglish(Array.from(deps).sort().map(function (name) {\n          return \"'\" + name + \"'\";\n        })) + (\". Either \" + fixVerb + \" \" + (deps.size > 1 ? 'them' : 'it') + \" or remove the dependency array.\");\n      }\n\n      var extraWarning = '';\n\n      if (unnecessaryDependencies.size > 0) {\n        var badRef = null;\n        Array.from(unnecessaryDependencies.keys()).forEach(function (key) {\n          if (badRef !== null) {\n            return;\n          }\n\n          if (key.endsWith('.current')) {\n            badRef = key;\n          }\n        });\n\n        if (badRef !== null) {\n          extraWarning = \" Mutable values like '\" + badRef + \"' aren't valid dependencies \" + \"because mutating them doesn't re-render the component.\";\n        } else if (externalDependencies.size > 0) {\n          var dep = Array.from(externalDependencies)[0]; // Don't show this warning for things that likely just got moved *inside* the callback\n          // because in that case they're clearly not referring to globals.\n\n          if (!scope.set.has(dep)) {\n            extraWarning = \" Outer scope values like '\" + dep + \"' aren't valid dependencies \" + \"because mutating them doesn't re-render the component.\";\n          }\n        }\n      } // `props.foo()` marks `props` as a dependency because it has\n      // a `this` value. This warning can be confusing.\n      // So if we're going to show it, append a clarification.\n\n\n      if (!extraWarning && missingDependencies.has('props')) {\n        var propDep = dependencies.get('props');\n\n        if (propDep == null) {\n          return;\n        }\n\n        var refs = propDep.references;\n\n        if (!Array.isArray(refs)) {\n          return;\n        }\n\n        var isPropsOnlyUsedInMembers = true;\n\n        for (var i = 0; i < refs.length; i++) {\n          var ref = refs[i];\n          var id = fastFindReferenceWithParent(componentScope.block, ref.identifier);\n\n          if (!id) {\n            isPropsOnlyUsedInMembers = false;\n            break;\n          }\n\n          var parent = id.parent;\n\n          if (parent == null) {\n            isPropsOnlyUsedInMembers = false;\n            break;\n          }\n\n          if (parent.type !== 'MemberExpression') {\n            isPropsOnlyUsedInMembers = false;\n            break;\n          }\n        }\n\n        if (isPropsOnlyUsedInMembers) {\n          extraWarning = \" However, 'props' will change when *any* prop changes, so the \" + \"preferred fix is to destructure the 'props' object outside of \" + (\"the \" + reactiveHookName + \" call and refer to those specific props \") + (\"inside \" + context.getSource(reactiveHook) + \".\");\n        }\n      }\n\n      if (!extraWarning && missingDependencies.size > 0) {\n        // See if the user is trying to avoid specifying a callable prop.\n        // This usually means they're unaware of useCallback.\n        var missingCallbackDep = null;\n        missingDependencies.forEach(function (missingDep) {\n          if (missingCallbackDep) {\n            return;\n          } // Is this a variable from top scope?\n\n\n          var topScopeRef = componentScope.set.get(missingDep);\n          var usedDep = dependencies.get(missingDep);\n\n          if (usedDep.references[0].resolved !== topScopeRef) {\n            return;\n          } // Is this a destructured prop?\n\n\n          var def = topScopeRef.defs[0];\n\n          if (def == null || def.name == null || def.type !== 'Parameter') {\n            return;\n          } // Was it called in at least one case? Then it's a function.\n\n\n          var isFunctionCall = false;\n          var id;\n\n          for (var _i2 = 0; _i2 < usedDep.references.length; _i2++) {\n            id = usedDep.references[_i2].identifier;\n\n            if (id != null && id.parent != null && id.parent.type === 'CallExpression' && id.parent.callee === id) {\n              isFunctionCall = true;\n              break;\n            }\n          }\n\n          if (!isFunctionCall) {\n            return;\n          } // If it's missing (i.e. in component scope) *and* it's a parameter\n          // then it is definitely coming from props destructuring.\n          // (It could also be props itself but we wouldn't be calling it then.)\n\n\n          missingCallbackDep = missingDep;\n        });\n\n        if (missingCallbackDep !== null) {\n          extraWarning = \" If '\" + missingCallbackDep + \"' changes too often, \" + \"find the parent component that defines it \" + \"and wrap that definition in useCallback.\";\n        }\n      }\n\n      if (!extraWarning && missingDependencies.size > 0) {\n        var setStateRecommendation = null;\n        missingDependencies.forEach(function (missingDep) {\n          if (setStateRecommendation !== null) {\n            return;\n          }\n\n          var usedDep = dependencies.get(missingDep);\n          var references = usedDep.references;\n          var id;\n          var maybeCall;\n\n          for (var _i3 = 0; _i3 < references.length; _i3++) {\n            id = references[_i3].identifier;\n            maybeCall = id.parent; // Try to see if we have setState(someExpr(missingDep)).\n\n            while (maybeCall != null && maybeCall !== componentScope.block) {\n              if (maybeCall.type === 'CallExpression') {\n                var correspondingStateVariable = setStateCallSites.get(maybeCall.callee);\n\n                if (correspondingStateVariable != null) {\n                  if (correspondingStateVariable.name === missingDep) {\n                    // setCount(count + 1)\n                    setStateRecommendation = {\n                      missingDep: missingDep,\n                      setter: maybeCall.callee.name,\n                      form: 'updater'\n                    };\n                  } else if (stateVariables.has(id)) {\n                    // setCount(count + increment)\n                    setStateRecommendation = {\n                      missingDep: missingDep,\n                      setter: maybeCall.callee.name,\n                      form: 'reducer'\n                    };\n                  } else {\n                    var resolved = references[_i3].resolved;\n\n                    if (resolved != null) {\n                      // If it's a parameter *and* a missing dep,\n                      // it must be a prop or something inside a prop.\n                      // Therefore, recommend an inline reducer.\n                      var def = resolved.defs[0];\n\n                      if (def != null && def.type === 'Parameter') {\n                        setStateRecommendation = {\n                          missingDep: missingDep,\n                          setter: maybeCall.callee.name,\n                          form: 'inlineReducer'\n                        };\n                      }\n                    }\n                  }\n\n                  break;\n                }\n              }\n\n              maybeCall = maybeCall.parent;\n            }\n\n            if (setStateRecommendation !== null) {\n              break;\n            }\n          }\n        });\n\n        if (setStateRecommendation !== null) {\n          switch (setStateRecommendation.form) {\n            case 'reducer':\n              extraWarning = \" You can also replace multiple useState variables with useReducer \" + (\"if '\" + setStateRecommendation.setter + \"' needs the \") + (\"current value of '\" + setStateRecommendation.missingDep + \"'.\");\n              break;\n\n            case 'inlineReducer':\n              extraWarning = \" If '\" + setStateRecommendation.setter + \"' needs the \" + (\"current value of '\" + setStateRecommendation.missingDep + \"', \") + \"you can also switch to useReducer instead of useState and \" + (\"read '\" + setStateRecommendation.missingDep + \"' in the reducer.\");\n              break;\n\n            case 'updater':\n              extraWarning = \" You can also do a functional update '\" + setStateRecommendation.setter + \"(\" + setStateRecommendation.missingDep.substring(0, 1) + \" => ...)' if you only need '\" + setStateRecommendation.missingDep + \"'\" + (\" in the '\" + setStateRecommendation.setter + \"' call.\");\n              break;\n\n            default:\n              throw new Error('Unknown case.');\n          }\n        }\n      }\n\n      context.report({\n        node: declaredDependenciesNode,\n        message: \"React Hook \" + context.getSource(reactiveHook) + \" has \" + ( // To avoid a long message, show the next actionable item.\n        getWarningMessage(missingDependencies, 'a', 'missing', 'include') || getWarningMessage(unnecessaryDependencies, 'an', 'unnecessary', 'exclude') || getWarningMessage(duplicateDependencies, 'a', 'duplicate', 'omit')) + extraWarning,\n        fix: function (fixer) {\n          // TODO: consider preserving the comments or formatting?\n          return fixer.replaceText(declaredDependenciesNode, \"[\" + suggestedDependencies.join(', ') + \"]\");\n        }\n      });\n    }\n  }\n}; // The meat of the logic.\n\nfunction collectRecommendations(_ref5) {\n  var dependencies = _ref5.dependencies,\n      declaredDependencies = _ref5.declaredDependencies,\n      optionalDependencies = _ref5.optionalDependencies,\n      externalDependencies = _ref5.externalDependencies,\n      isEffect = _ref5.isEffect;\n  // Our primary data structure.\n  // It is a logical representation of property chains:\n  // `props` -> `props.foo` -> `props.foo.bar` -> `props.foo.bar.baz`\n  //         -> `props.lol`\n  //         -> `props.huh` -> `props.huh.okay`\n  //         -> `props.wow`\n  // We'll use it to mark nodes that are *used* by the programmer,\n  // and the nodes that were *declared* as deps. Then we will\n  // traverse it to learn which deps are missing or unnecessary.\n  var depTree = createDepTree();\n\n  function createDepTree() {\n    return {\n      isRequired: false,\n      // True if used in code\n      isSatisfiedRecursively: false,\n      // True if specified in deps\n      hasRequiredNodesBelow: false,\n      // True if something deeper is used by code\n      children: new Map() // Nodes for properties\n\n    };\n  } // Mark all required nodes first.\n  // Imagine exclamation marks next to each used deep property.\n\n\n  dependencies.forEach(function (_, key) {\n    var node = getOrCreateNodeByPath(depTree, key);\n    node.isRequired = true;\n    markAllParentsByPath(depTree, key, function (parent) {\n      parent.hasRequiredNodesBelow = true;\n    });\n  }); // Mark all satisfied nodes.\n  // Imagine checkmarks next to each declared dependency.\n\n  declaredDependencies.forEach(function (_ref6) {\n    var key = _ref6.key;\n    var node = getOrCreateNodeByPath(depTree, key);\n    node.isSatisfiedRecursively = true;\n  });\n  optionalDependencies.forEach(function (key) {\n    var node = getOrCreateNodeByPath(depTree, key);\n    node.isSatisfiedRecursively = true;\n  }); // Tree manipulation helpers.\n\n  function getOrCreateNodeByPath(rootNode, path) {\n    var keys = path.split('.');\n    var node = rootNode;\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var key = _step3.value;\n        var child = node.children.get(key);\n\n        if (!child) {\n          child = createDepTree();\n          node.children.set(key, child);\n        }\n\n        node = child;\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    return node;\n  }\n\n  function markAllParentsByPath(rootNode, path, fn) {\n    var keys = path.split('.');\n    var node = rootNode;\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = keys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var key = _step4.value;\n        var child = node.children.get(key);\n\n        if (!child) {\n          return;\n        }\n\n        fn(child);\n        node = child;\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  } // Now we can learn which dependencies are missing or necessary.\n\n\n  var missingDependencies = new Set();\n  var satisfyingDependencies = new Set();\n  scanTreeRecursively(depTree, missingDependencies, satisfyingDependencies, function (key) {\n    return key;\n  });\n\n  function scanTreeRecursively(node, missingPaths, satisfyingPaths, keyToPath) {\n    node.children.forEach(function (child, key) {\n      var path = keyToPath(key);\n\n      if (child.isSatisfiedRecursively) {\n        if (child.hasRequiredNodesBelow) {\n          // Remember this dep actually satisfied something.\n          satisfyingPaths.add(path);\n        } // It doesn't matter if there's something deeper.\n        // It would be transitively satisfied since we assume immutability.\n        // `props.foo` is enough if you read `props.foo.id`.\n\n\n        return;\n      }\n\n      if (child.isRequired) {\n        // Remember that no declared deps satisfied this node.\n        missingPaths.add(path); // If we got here, nothing in its subtree was satisfied.\n        // No need to search further.\n\n        return;\n      }\n\n      scanTreeRecursively(child, missingPaths, satisfyingPaths, function (childKey) {\n        return path + '.' + childKey;\n      });\n    });\n  } // Collect suggestions in the order they were originally specified.\n\n\n  var suggestedDependencies = [];\n  var unnecessaryDependencies = new Set();\n  var duplicateDependencies = new Set();\n  declaredDependencies.forEach(function (_ref7) {\n    var key = _ref7.key;\n\n    // Does this declared dep satisfy a real need?\n    if (satisfyingDependencies.has(key)) {\n      if (suggestedDependencies.indexOf(key) === -1) {\n        // Good one.\n        suggestedDependencies.push(key);\n      } else {\n        // Duplicate.\n        duplicateDependencies.add(key);\n      }\n    } else {\n      if (isEffect && !key.endsWith('.current') && !externalDependencies.has(key)) {\n        // Effects are allowed extra \"unnecessary\" deps.\n        // Such as resetting scroll when ID changes.\n        // Consider them legit.\n        // The exception is ref.current which is always wrong.\n        if (suggestedDependencies.indexOf(key) === -1) {\n          suggestedDependencies.push(key);\n        }\n      } else {\n        // It's definitely not needed.\n        unnecessaryDependencies.add(key);\n      }\n    }\n  }); // Then add the missing ones at the end.\n\n  missingDependencies.forEach(function (key) {\n    suggestedDependencies.push(key);\n  });\n  return {\n    suggestedDependencies: suggestedDependencies,\n    unnecessaryDependencies: unnecessaryDependencies,\n    duplicateDependencies: duplicateDependencies,\n    missingDependencies: missingDependencies\n  };\n} // Finds functions declared as dependencies\n// that would invalidate on every render.\n\n\nfunction scanForDeclaredBareFunctions(_ref8) {\n  var declaredDependencies = _ref8.declaredDependencies,\n      declaredDependenciesNode = _ref8.declaredDependenciesNode,\n      componentScope = _ref8.componentScope,\n      scope = _ref8.scope;\n  var bareFunctions = declaredDependencies.map(function (_ref9) {\n    var key = _ref9.key;\n    var fnRef = componentScope.set.get(key);\n\n    if (fnRef == null) {\n      return null;\n    }\n\n    var fnNode = fnRef.defs[0];\n\n    if (fnNode == null) {\n      return null;\n    } // const handleChange = function () {}\n    // const handleChange = () => {}\n\n\n    if (fnNode.type === 'Variable' && fnNode.node.type === 'VariableDeclarator' && fnNode.node.init != null && (fnNode.node.init.type === 'ArrowFunctionExpression' || fnNode.node.init.type === 'FunctionExpression')) {\n      return fnRef;\n    } // function handleChange() {}\n\n\n    if (fnNode.type === 'FunctionName' && fnNode.node.type === 'FunctionDeclaration') {\n      return fnRef;\n    }\n\n    return null;\n  }).filter(Boolean);\n\n  function isUsedOutsideOfHook(fnRef) {\n    var foundWriteExpr = false;\n\n    for (var i = 0; i < fnRef.references.length; i++) {\n      var reference = fnRef.references[i];\n\n      if (reference.writeExpr) {\n        if (foundWriteExpr) {\n          // Two writes to the same function.\n          return true;\n        } else {\n          // Ignore first write as it's not usage.\n          foundWriteExpr = true;\n          continue;\n        }\n      }\n\n      var currentScope = reference.from;\n\n      while (currentScope !== scope && currentScope != null) {\n        currentScope = currentScope.upper;\n      }\n\n      if (currentScope !== scope) {\n        // This reference is outside the Hook callback.\n        // It can only be legit if it's the deps array.\n        if (!isAncestorNodeOf(declaredDependenciesNode, reference.identifier)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return bareFunctions.map(function (fnRef) {\n    return {\n      fn: fnRef.defs[0],\n      suggestUseCallback: isUsedOutsideOfHook(fnRef)\n    };\n  });\n}\n/**\n * Assuming () means the passed/returned node:\n * (props) => (props)\n * props.(foo) => (props.foo)\n * props.foo.(bar) => (props).foo.bar\n * props.foo.bar.(baz) => (props).foo.bar.baz\n */\n\n\nfunction getDependency(node) {\n  if (node.parent.type === 'MemberExpression' && node.parent.object === node && node.parent.property.name !== 'current' && !node.parent.computed && !(node.parent.parent != null && node.parent.parent.type === 'CallExpression' && node.parent.parent.callee === node.parent)) {\n    return getDependency(node.parent);\n  } else {\n    return node;\n  }\n}\n/**\n * Assuming () means the passed node.\n * (foo) -> 'foo'\n * foo.(bar) -> 'foo.bar'\n * foo.bar.(baz) -> 'foo.bar.baz'\n * Otherwise throw.\n */\n\n\nfunction toPropertyAccessString(node) {\n  if (node.type === 'Identifier') {\n    return node.name;\n  } else if (node.type === 'MemberExpression' && !node.computed) {\n    var object = toPropertyAccessString(node.object);\n    var property = toPropertyAccessString(node.property);\n    return object + \".\" + property;\n  } else {\n    throw new Error(\"Unsupported node type: \" + node.type);\n  }\n}\n\nfunction getNodeWithoutReactNamespace(node, options) {\n  if (node.type === 'MemberExpression' && node.object.type === 'Identifier' && node.object.name === 'React' && node.property.type === 'Identifier' && !node.computed) {\n    return node.property;\n  }\n\n  return node;\n} // What's the index of callback that needs to be analyzed for a given Hook?\n// -1 if it's not a Hook we care about (e.g. useState).\n// 0 for useEffect/useMemo/useCallback(fn).\n// 1 for useImperativeHandle(ref, fn).\n// For additionally configured Hooks, assume that they're like useEffect (0).\n\n\nfunction getReactiveHookCallbackIndex(calleeNode, options) {\n  var node = getNodeWithoutReactNamespace(calleeNode);\n\n  if (node.type !== 'Identifier') {\n    return null;\n  }\n\n  switch (node.name) {\n    case 'useEffect':\n    case 'useLayoutEffect':\n    case 'useCallback':\n    case 'useMemo':\n      // useEffect(fn)\n      return 0;\n\n    case 'useImperativeHandle':\n      // useImperativeHandle(ref, fn)\n      return 1;\n\n    default:\n      if (node === calleeNode && options && options.additionalHooks) {\n        // Allow the user to provide a regular expression which enables the lint to\n        // target custom reactive hooks.\n        var name;\n\n        try {\n          name = toPropertyAccessString(node);\n        } catch (error) {\n          if (/Unsupported node type/.test(error.message)) {\n            return 0;\n          } else {\n            throw error;\n          }\n        }\n\n        return options.additionalHooks.test(name) ? 0 : -1;\n      } else {\n        return -1;\n      }\n\n  }\n}\n/**\n * ESLint won't assign node.parent to references from context.getScope()\n *\n * So instead we search for the node from an ancestor assigning node.parent\n * as we go. This mutates the AST.\n *\n * This traversal is:\n * - optimized by only searching nodes with a range surrounding our target node\n * - agnostic to AST node types, it looks for `{ type: string, ... }`\n */\n\n\nfunction fastFindReferenceWithParent(start, target) {\n  var queue = [start];\n  var item = null;\n\n  while (queue.length) {\n    item = queue.shift();\n\n    if (isSameIdentifier(item, target)) {\n      return item;\n    }\n\n    if (!isAncestorNodeOf(item, target)) {\n      continue;\n    }\n\n    for (var _i4 = 0, _Object$entries = Object.entries(item); _i4 < _Object$entries.length; _i4++) {\n      var _Object$entries$_i = _Object$entries[_i4],\n          key = _Object$entries$_i[0],\n          value = _Object$entries$_i[1];\n\n      if (key === 'parent') {\n        continue;\n      }\n\n      if (isNodeLike(value)) {\n        value.parent = item;\n        queue.push(value);\n      } else if (Array.isArray(value)) {\n        value.forEach(function (val) {\n          if (isNodeLike(val)) {\n            val.parent = item;\n            queue.push(val);\n          }\n        });\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction joinEnglish(arr) {\n  var s = '';\n\n  for (var i = 0; i < arr.length; i++) {\n    s += arr[i];\n\n    if (i === 0 && arr.length === 2) {\n      s += ' and ';\n    } else if (i === arr.length - 2 && arr.length > 2) {\n      s += ', and ';\n    } else if (i < arr.length - 1) {\n      s += ', ';\n    }\n  }\n\n  return s;\n}\n\nfunction isNodeLike(val) {\n  return typeof val === 'object' && val !== null && !Array.isArray(val) && typeof val.type === 'string';\n}\n\nfunction isSameIdentifier(a, b) {\n  return a.type === 'Identifier' && a.name === b.name && a.range[0] === b.range[0] && a.range[1] === b.range[1];\n}\n\nfunction isAncestorNodeOf(a, b) {\n  return a.range[0] <= b.range[0] && a.range[1] >= b.range[1];\n}\n\nvar rules = {\n  'rules-of-hooks': RuleOfHooks,\n  'exhaustive-deps': ExhaustiveDeps\n};\n\nvar src = Object.freeze({\n\trules: rules\n});\n\nvar eslintPluginReactHooks = src;\n\nmodule.exports = eslintPluginReactHooks;\n  })();\n}\n"]},"metadata":{},"sourceType":"script"}